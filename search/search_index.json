{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Seqtool is a  fast and flexible command line program for dealing with large amounts of biological sequences. It provides different subcommands for converting, inspecting and modifying sequences. The standalone binary (5-7 MB) is simply named <code>st</code> to save some typing.</p> <p></p> <p>Note: this page describes the development version 0.4-beta. The older stable version (v0.3.0) is documented here.</p>"},{"location":"#downloads","title":"Downloads","text":"<p>\ud83d\udce5 download beta release (v0.4.0-beta.3)</p> <p>Should be pretty safe to use despite the considerable refactoring. Approximate matching (find command) is yet to be fully tested.</p> <p>\ud83d\udce5 download stable release (v0.3.0)</p> <p>\u26a0 Note: there are a few unfixed bugs in v0.3.0 (currently) when reading GZIP files or searching/replacing; see CHANGELOG for v0.4.0-beta.</p>"},{"location":"#feature-overview","title":"Feature overview","text":""},{"location":"#file-formats","title":"File formats","text":"<p>Reads and writes FASTA, FASTQ and CSV/TSV, optionally compressed with GZIP, BZIP2, or the faster and more modern Zstandard or LZ4 formats</p>  Example: compressed FASTQ to FASTA  <p>Combine multiple compressed FASTQ files, converting them to FASTA, using pass.</p> <pre><code>st pass file1.fastq.gz file2.fastq.gz -o output.fasta\n</code></pre> <p>Note: almost every command can read multiple input files and convert between formats, but pass does nothing other than reading and writing while other command perform certain actions.</p>  Example: FASTA to tab-separated list  <p>Aside from ID and sequence, any variable/function such as the sequence length (<code>seqlen</code>) can be written to  delimited text.</p> <pre><code>st pass input.fasta --to-tsv id,seq,seqlen\n</code></pre> <pre><code>id1 ACG 3\nid1 ACGTACGT    7\nid1 ACGTA   5\n</code></pre>"},{"location":"#highly-versatile-thanks-to-variablesfunctions","title":"Highly versatile thanks to variables/functions","text":"<p>See also variables/functions for more details.</p>  Example: count sequences in a large set of FASTQ files  <pre><code>st count -k path data/*.fastq.gz\n</code></pre> <pre><code>data/sample1.fastq.gz   30601\ndata/sample2.fastq.gz   15702\ndata/sample3.fastq.gz   264965\ndata/sample4.fastq.gz   1120\ndata/sample5.fastq.gz   7021\n(...)\n</code></pre> <p>In count, one or several categorical variables/functions can be specified with <code>-k/--key</code>.</p>  Example: summarize the GC content in 10% intervals  <p>The function <code>bin(variable, interval)</code> groups continuous numeric values into intervals</p> <pre><code>st count -k 'bin(gc_percent, 10)' sequences.fasta\n</code></pre> <pre><code>(10, 20]    57\n(20, 30]    2113\n(30, 40]    11076\n(40, 50]    7184\n(50, 60]    12\n</code></pre>  Example: Assign new sequence IDs  <pre><code>st set -i 'seq_{num}' seqs.fasta &gt; renamed.fasta\n</code></pre> <pre><code>&gt;seq_1\nSEQUENCE\n&gt;seq_2\nSEQUENCE\n&gt;seq_3\nSEQUENCE\n(...)\n</code></pre>  Example: De-replicate by description and sequence  <p><code>seqs.fasta</code> with a 'group' annotation in the header:</p> <pre><code>&gt;id1 group1\nSEQUENCE1\n&gt;id2 group1\nSEQUENCE2\n&gt;id3 group1\nSEQUENCE2\n&gt;id4 group2\nSEQUENCE1\n&gt;id5 group2\nSEQUENCE1\n</code></pre> <pre><code>st unique 'desc,seq' seqs.fasta &gt; grouped_uniques.fasta\n</code></pre> <pre><code>&gt;id1 group1\nSEQUENCE1\n&gt;id2 group1\nSEQUENCE2\n&gt;id4 group2\nSEQUENCE1\n</code></pre>"},{"location":"#expressions","title":"Expressions","text":"<p>From simple math to complicated filter expressions, the tiny integrated JavaScript engine (QuickJS) offers countless possibilities for customized sequence processing.</p>  Example: filter FASTQ sequences by quality and length  <p>This filter command removes sequencing reads with more than one expected sequencing error (like USEARCH can do) or sequence length of &lt;100 bp.</p> <pre><code>st filter 'exp_err &lt; 1 &amp;&amp; seqlen &gt;= 100' reads.fastq &gt; filtered.fastq\n</code></pre>"},{"location":"#header-attributes-for-metadata-storage","title":"Header attributes for metadata storage","text":"<p><code>key=value</code> header attributes allow storing and passing on all kinds of information</p>  Example: De-replicate by sequence (seq variable) and/or other properties    <p>The unique command returns all unique sequences and annotates the number of records with the same sequence in the header:</p> <pre><code>st unique seq -a abund={n_duplicates} input.fasta &gt; uniques.fasta\n</code></pre> <pre><code>&gt;id1 abund=3\nTCTTTAATAACCTGATTAG\n&gt;id3 abund=1\nGGAGGATCCGAGCG\n(...)\n</code></pre> <p>It is also possible to de-replicate by multiple keys, e.g. by sequence, but grouped by a <code>sample</code> attribute in the header:</p> <pre><code>st unique 'seq,attr(sample)' input.fasta &gt; uniques.fasta\n</code></pre> <pre><code>&gt;id1 sample=1\nSEQUENCE1\n&gt;id3 sample=2\nSEQUENCE2\n&gt;id10 sample=1\nSEQUENCE3\n&gt;id11 sample=3\nSEQUENCE4\n(...)\n</code></pre>  Example: pre-processing of mixed multi-marker amplicon sequences (primer trimming, grouping by amplicon)  <p>These steps could be part of an amplicon pipeline that de-multiplexes multi-marker amplicons. find searches for a set of primers, which are removed by trim, and finally split distributes the sequences into different files named by the forward primer.</p> <p>primers.fasta</p> <pre><code>&gt;prA\nPRIMER\n&gt;prB\nPRIMER\n</code></pre> <p>Command for searching/trimming</p> <pre><code>st find file:primers.fasta -a primer='{pattern_name}' -a end='{match_end}' sequences.fasta |\n  st trim -e '{attr(end)}..' | \n  st split -o '{attr(primer)}'\n</code></pre> prA.fasta  prB.fasta undefined.fasta <pre><code>&gt;id1 primer=prA end=22\nSEQUENCE\n&gt;id4 primer=prA end=21\nSEQUENCE\n(...)\n</code></pre> <pre><code>&gt;id2 primer=prB end=20\nSEQUENCE\n&gt;id3 primer=prB end=22\nSEQUENCE\n(...)\n</code></pre> <pre><code>&gt;id5 primer=undefined end=undefined\nUNTRIMMEDSEQUENCE\n(...)\n</code></pre> Note: no primer, sequence not trimmed since <code>end=undefined</code> (see ranges)."},{"location":"#integration-of-external-metadata","title":"Integration of external metadata","text":"<p>Integration of sequence metadata sources in the form of delimited text</p>  Example: Add Genus names from a separate tab-separated list  input.fasta genus.tsv <pre><code>&gt;id1\nSEQUENCE\n&gt;id2\nSEQUENCE\n(...)\n</code></pre> <pre><code>id  genus\nseq1  Actinomyces\nseq2  Amycolatopsis\n(...)\n</code></pre> <p>Using <code>-m/--meta</code> to include <code>genus.tsv</code> as metadata source:</p> <pre><code>st set -m genus.tsv --desc '{meta(genus)}' input.fasta &gt; with_genus.fasta\n</code></pre> with_genus.fasta <pre><code>&gt;seq1 Actinomyces\nSEQUENCE\n&gt;seq2 Amycolatopsis\nSEQUENCE\n(...)\n</code></pre>  Example: Choose specific sequences given a separate file with an ID list  input.fasta id_list.txt <pre><code>&gt;id1\nSEQUENCE\n&gt;id2\nSEQUENCE\n&gt;id3\nSEQUENCE\n&gt;id4\nSEQUENCE\n</code></pre> <pre><code>id1\nid4\n</code></pre> <pre><code>st filter -m id_list.txt 'has_meta()' input.fasta &gt; subset.fasta\n</code></pre> subset.fasta <pre><code>&gt;id1\nSEQUENCE\n&gt;id4\nSEQUENCE\n</code></pre>"},{"location":"#commands","title":"Commands","text":""},{"location":"#basic-conversionediting","title":"Basic conversion/editing","text":"<ul> <li>pass: Directly pass input to output without any processing, useful for converting and attribute setting</li> </ul>"},{"location":"#information-about-sequences","title":"Information about sequences","text":"<ul> <li>view: View biological sequences, colored by base / amino acid, or by sequence quality</li> <li>count: Count all records in the input (total or categorized by variables/functions)</li> <li>stat: Return per-sequence statistics as tab delimited list</li> </ul>"},{"location":"#subsetreorganizecompare","title":"Subset/reorganize/compare","text":"<ul> <li>sort: Sort records by sequence or any other criterion</li> <li>unique: De-replicate by sequence and/or other properties, returning only unique records</li> <li>filter: Keep/exclude sequences based on different properties with a mathematical (JavaScript) expression</li> <li>split: Distribute sequences into multiple files based on a variable/function or advanced expression</li> <li>cmp: Compare two input files/streams</li> <li>sample: Get a random subset of sequences; either a fixed number or an approximate fraction of the input</li> <li>slice: Return a range of sequence records from the input</li> <li>head: Return the first N sequences</li> <li>tail: Return the last N sequences</li> <li>interleave: Interleave records of all files in the input</li> </ul>"},{"location":"#search-and-replace","title":"Search and replace","text":"<ul> <li>find: Search for pattern(s) in sequences or sequene headers for record filtering, pattern replacement or passing hits to next command</li> <li>replace: Fast and simple pattern replacement in sequences or headers</li> </ul>"},{"location":"#modifying-commands","title":"Modifying commands","text":"<ul> <li>del: Delete header ID/description and/or attributes</li> <li>set: Replace the header, header attributes or sequence with new content</li> <li>trim: Trim sequences on the left and/or right (single range) or extract and concatenate several ranges</li> <li>mask: Soft or hard mask sequence ranges</li> <li>upper: Convert sequences to uppercase</li> <li>lower: Convert sequences to lowercase</li> <li>revcomp: Reverse complements DNA or RNA sequences</li> <li>concat: Concatenates sequences/alignments from different files</li> </ul>"},{"location":"#comparison-with-other-tools","title":"Comparison with other tools","text":"<p>There are other tools with a similar focus such as Seqtk, SeqKit, the FASTX-Toolkit, as well as the more specialized USEARCH and VSEARCH offering some of the functions as well.</p> <p>Seqtool performs well compared to these tools on a selection of diverse tasks:</p> <p>Comparison of tools</p>"},{"location":"#license","title":"License","text":"<p>Either MIT or Apache-2.0 at your choice</p>"},{"location":"attributes/","title":"FASTA/FASTQ header attributes","text":"<p>Attributes are key-value annotations stored in the FASTA/FASTQ definition line.</p>"},{"location":"attributes/#in-a-nutshell","title":"In a nutshell","text":"<ul> <li>Adding attributes: <code>-a/--attr</code> key='<code>{variables/functions...}</code>'   or <code>-A/--attr-append</code> (multiple possible), results in headers like   this: <code>&gt;id description attribute=value</code></li> <li>Accessing attributes: <code>attr(name)</code> or <code>opt_attr(name)</code> if some records    have missing/<code>undefined</code> attributes.   To simultaneously delete the accessed value, use <code>attr_del(name)</code> or <code>opt_attr_del(name)</code></li> <li>To change the default format of recognized and inserted attributes, use   <code>--attr-fmt</code> or the <code>ST_ATTR_FORMAT</code> environment variable.   Example: <code>st count -k 'attr(abund)' --attr-fmt ';key=value'</code>.</li> </ul> <p>See also variable reference and detailed description of command-line options</p>"},{"location":"attributes/#adding-attributes-to-headers","title":"Adding attributes to headers","text":"<p>Attributes are added in any command by using the <code>-a/--attr</code> option:</p> <pre><code>st pass --attr key=value input.fasta\n# shorter:\nst . -a key=value input.fasta\n</code></pre> <p>Output:</p> <pre><code>&gt;id1 key=value\nSEQUENCE\n&gt;id2 key=value\nSEQUENCE\n(...)\n</code></pre> <p>The <code>-a/--attr</code> can be used multiple times:</p> <pre><code>st . -a a=1 -a b=2 input.fasta\n</code></pre> <pre><code>&gt;id1 a=1 b=2\nSEQUENCE\n&gt;id2 a=1 b=2\nSEQUENCE\n(...)\n</code></pre> <p>Attributes become useful when using variables/functions:</p> <pre><code>st pass -a num='{num}' -a gc_content='{gc_percent}' input.fasta\n</code></pre> <pre><code>&gt;id1 num=1 gc_content=54.3046357615894\nSEQUENCE\n&gt;id2 num=2 gc_content=42.019867549668874\nSEQUENCE\n(...)\n</code></pre>"},{"location":"attributes/#performance-optimization","title":"Performance optimization","text":"<p>In the standard worklow with <code>-a/--attr</code>, seqtool has to check if an attribute with the same name is already present. To omit this check, use <code>-A/--attr-append</code>. However, this comes with the risk of duplicating the attribute with the same name, resulting in the appended new attribute being ignored when accessing with <code>attr(...)</code> (see below).</p> <p>The user thus needs to be sure that an attribute with the same name is not already present.</p>"},{"location":"attributes/#accessing-attributes","title":"Accessing attributes","text":"<p>Attributes in the sequence headers are accessed using the internal function <code>attr(name)</code> at any place where variables/functions can be used, that is:</p> <p>In a multitude of commands:</p> <p>count, stat, sort, unique, filter, split, set, trim, mask, find, replace. Examples assuming <code>attribute</code> in headers, e.g. <code>&gt;id1 attribute=value1</code></p> <pre><code>st sort 'attr(attribute)' seqs.fasta\nst split seqs.fasta -o '{attr(attribute)}.fasta'  # -&gt; value1.fasta, value2.fasta, etc.\nst find PRRIMERSEQUENCE -a pos='{match_start}' seqs.fasta |   # e.g. &gt;id1 pos=2\n  st count -k 'attr(pos)'\n</code></pre> <p>When setting new attributes:</p> <pre><code># seqs.fasta: &gt;id1 key=value\nst pass -a new_key='{attr(key)}_with_suffix' seqs.fasta\n# output: &gt;id1 key=value new_key=value_with_suffix\n</code></pre> <p>In delimited text output:</p> <pre><code># seqs.fasta: &gt;id1 key=value\nst pass seqs.fasta --to-tsv 'id,attr(key)'\n# id1   value\n# id2   value2\n# (...)\n</code></pre>"},{"location":"attributes/#interacting-with-other-software-different-attribute-formats","title":"Interacting with other software (different attribute formats)","text":"<p>Some programs use some form of <code>key=value</code> attributes in headers, too. For instance, USEARCH and VSEARCH indicate the size (number of sequences) of clusters like this:</p> <p><pre><code>usearch -cluster_fast seqs.fasta -id 0.97 -sizeout -centroids clusters.fasta\n</code></pre> <pre><code>&gt;seq_1;size=343;\nSEQUENCE\n(...)\n</code></pre></p> <p>In this case, the <code>size</code> attribute is appended to the sequence ID (without space) and preceded by a semicolon. In order to recognize the attribute, we need to set the format:</p> <p>Extract cluster ids and sizes into a tab delimited output</p> <p><pre><code>st . --to-tsv 'id,attr(size)' --attr-fmt \";key=value\" clusters.fasta\n</code></pre> <pre><code>seq_1   343\n(...)\n</code></pre></p> <p>Instead writing <code>attr-fmt</code> in every command, we can also define the format as environment variable (assuming it does not change too often):</p> <pre><code>export ST_ATTR_FORMAT=\";key=value\"\nst . --to-tsv 'id,attr(size)' clusters.fasta\n# to override just once given headers like this: &gt;id;size=5 another_attr=somevalue\nst . --to-tsv 'id,attr(another_attr)' --attr-fmt ' key=value' clusters.fasta\n</code></pre>"},{"location":"attributes/#more-complicated-header-annotations","title":"More complicated header annotations","text":"<p>Advanced patterns not following the simple <code>key=value</code> format can be parsed and converted standard header annotations using the  <code>-r/--regex</code> search feature of the find command.</p>"},{"location":"attributes/#missingundefined-attributes","title":"Missing/undefined attributes","text":"<p>Attributes should normally not be missing. In the following <code>seqs.fasta</code>, the attribute <code>a</code> is missing in one record and <code>undefined</code> in another:</p> <pre><code>&gt;id1 a=1\nSEQUENCE\n&gt;id2\nSEQUENCE\n&gt;id3 a=undefined\nSEQUENCE\n</code></pre> <pre><code>st count -k 'attr(a)' seqs.fasta\n</code></pre> <pre><code>Attribute 'a' not found in record 'id2'. Use 'opt_attr()' if attributes may be missing in some records.\nSet the correct attribute format with --attr-format.\n</code></pre> <p>Instead, use <code>opt_attr()</code> to avoid the error:</p> <pre><code>st count -k 'opt_attr(a)' seqs.fasta\n</code></pre> <pre><code>1   1\nundefined   2\n</code></pre> <p><code>undefined</code> is a special keyword that indicates missing data, so <code>id3</code> is treated as missing like <code>id2</code></p> <p>The <code>has_attr()</code> function is useful for filtering or other checks:</p> <p><pre><code>st filter 'has_attr(a)' seqs.fasta\n</code></pre> <pre><code>&gt;id1 a=1\nSEQUENCE\n</code></pre></p>"},{"location":"attributes/#deleting-attributes","title":"Deleting attributes","text":"<p>Attributes can be deleted using <code>attr_del()</code> and <code>opt_attr_del()</code>, if they should only serve for transient message passing between commands. In this case, the intermediate output has <code>pos=start:end</code> annotations in the headers:</p> <pre><code>st find SUBSEQ -a pos='{match_range}' seqs.fasta |\n    st mask 'attr_del(pos)' &gt; masked.fasta\n</code></pre> <p>Alternatively, use the del command:</p> <pre><code>st del --attrs attr1,attr2 seqs.fasta &gt; clean.fasta\n</code></pre>"},{"location":"cmds_basic/","title":"Basic conversion/editing","text":""},{"location":"cmds_basic/#basic-conversionediting","title":"Basic conversion/editing","text":"<ul> <li>pass: Directly pass input to output without any processing, useful for converting and attribute setting</li> </ul>"},{"location":"cmds_info/","title":"Information about sequences","text":""},{"location":"cmds_info/#information-about-sequences","title":"Information about sequences","text":"<ul> <li>view: View biological sequences, colored by base / amino acid, or by sequence quality</li> <li>count: Count all records in the input (total or categorized by variables/functions)</li> <li>stat: Return per-sequence statistics as tab delimited list</li> </ul>"},{"location":"cmds_mod/","title":"Modifying commands","text":""},{"location":"cmds_mod/#modifying-commands","title":"Modifying commands","text":"<ul> <li>del: Delete header ID/description and/or attributes</li> <li>set: Replace the header, header attributes or sequence with new content</li> <li>trim: Trim sequences on the left and/or right (single range) or extract and concatenate several ranges</li> <li>mask: Soft or hard mask sequence ranges</li> <li>upper: Convert sequences to uppercase</li> <li>lower: Convert sequences to lowercase</li> <li>revcomp: Reverse complements DNA or RNA sequences</li> <li>concat: Concatenates sequences/alignments from different files</li> </ul>"},{"location":"cmds_search_rep/","title":"Search and replace","text":""},{"location":"cmds_search_rep/#search-and-replace","title":"Search and replace","text":"<ul> <li>find: Search for pattern(s) in sequences or sequene headers for record filtering, pattern replacement or passing hits to next command</li> <li>replace: Fast and simple pattern replacement in sequences or headers</li> </ul>"},{"location":"cmds_sub_shuffle/","title":"Subset/reorganize/compare","text":""},{"location":"cmds_sub_shuffle/#subsetreorganizecompare","title":"Subset/reorganize/compare","text":"<ul> <li>sort: Sort records by sequence or any other criterion</li> <li>unique: De-replicate by sequence and/or other properties, returning only unique records</li> <li>filter: Keep/exclude sequences based on different properties with a mathematical (JavaScript) expression</li> <li>split: Distribute sequences into multiple files based on a variable/function or advanced expression</li> <li>cmp: Compare two input files/streams</li> <li>sample: Get a random subset of sequences; either a fixed number or an approximate fraction of the input</li> <li>slice: Return a range of sequence records from the input</li> <li>head: Return the first N sequences</li> <li>tail: Return the last N sequences</li> <li>interleave: Interleave records of all files in the input</li> </ul>"},{"location":"cmp/","title":"cmp","text":"<p>Compare two input files/streams</p> <p>In the default mode, two files/streams are compared by ID (<code>id</code> variable) and sequence hash (<code>seqhash</code> variable), ignoring descriptions in headers. The number of common and unique record numbers are reported to STDERR, unless <code>-q/--quiet</code> is specified.</p> <p>Note that the comparison key can be completely customized with <code>-k/--key</code> (see  help and <code>st cmp -V/--help-vars</code>). <p>If the memory limit is exceeded, two-pass scanning is activated. In this case, seekable files must be provided.</p> <p>If the the two input files/streams are known to be in sync, then <code>-O/--in-order</code> can be specified for faster comparison and lower memory usage. The key does not have to be unique in this mode.</p> <p>Examples:</p> <p>Compare records by ID and sequence (the default mode):</p> <p><code>st cmp file1.fasta file2.fasta</code> common  6 unique1 3 unique2 3</p> <p>Compare only by ID and visualize inconsistencies between sequences:</p> <p><code>st cmp -k id -d seq file1.fasta file2.fasta</code> seq_3: \u250c CACTTTCAACAACGGATCTCTTGGTTCTCGCATCGATGAAGAACGT\u2510 \u2514 CACTTTCAACAACGGATCTCTTG..TCTCGCATCGATGAAGAACGT\u2518</p> <p>common  7 unique1 2 unique2 1</p> <p><pre><code>Usage: st cmp [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Cmp' command options:\n  -k, --key &lt;FIELDS&gt;        The key used to compare the records in the two input\n                            files/streams. Keys must be unique in each input\n                            unless `-O/--in-order` is provided. Can be a single\n                            variable/function such as 'id', a composed string\n                            such as '{attr(a)}_{attr(b)}', or a comma-delimited\n                            list of these. `-k/--key` may also be provided\n                            multiple times, which is equivalent to a\n                            comma-delimited list [default: id,seqhash]\n  -d, --diff &lt;FIELDS&gt;       Print differences between the two inputs with\n                            respect to one or multiple extra properties, for\n                            records that are otherwise identical according to\n                            the comparison key (`-k/--key`). If two records\n                            differ by these extra given properties, a colored\n                            alignment is printed to STDERR\n  -O, --in-order            Provide this option if the two input files/streams\n                            are in the same order. Instead of scanning the whole\n                            output, reading and writing is done progressively.\n                            The same key may occur multiple times. Two records\n                            are assumed to be synchronized and idencical as long\n                            as they have the same key\n  -c, --check               Checks if the two files match exactly, and exits\n                            with an error if not\n      --common &lt;OUT&gt;        Write records from the first input to this output\n                            file (or `-` for STDOUT) if *also* present in the\n                            second input (according to the comparison of keys)\n                            [aliases: --common1, --c1]\n      --common2 &lt;OUT&gt;       Write records from the *second* input to the given\n                            output (file or `-` for STDOUT) if *also* present in\n                            the first input (according to the comparison of\n                            keys) [aliases: --c2]\n      --unique1 &lt;OUT&gt;       Write records from the first input to this output\n                            file (or `-` for STDOUT) if *not* present in the\n                            second input [aliases: --u1]\n      --unique2 &lt;OUT&gt;       Write records from the second input to this output\n                            file (or `-` for STDOUT) if *not* present in the\n                            first input [aliases: --u2]\n      --output2 &lt;OUT&gt;       Write the second input back to this output file (or\n                            - for STDOUT). Useful if only certain aspects of a\n                            record are compared, but records may still differ by\n                            other parts [aliases: --o2]\n  -2, --two-pass            Do the comparison in two passes (default:\n                            automatically done if memory limit reached)\n  -M, --max-mem &lt;SIZE&gt;      Maximum amount of memory (approximate) to use for\n                            de-duplicating. Either a plain number (bytes) a\n                            number with unit (K, M, G, T) based on powers of 2\n                            [default: 5G]\n      --diff-width &lt;CHARS&gt;  Maximum width of the `-d/--diff` output [default:\n                            80]\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"cmp/#variablesfunctions-provided-by-the-cmp-command","title":"Variables/functions provided by the 'cmp' command","text":"<p>see also <code>st cmp -V</code> or <code>st cmp --help-vars</code></p> category Record category: 'common' (record present in both files based on comparison of keys), 'unique1' (record only in first file), or 'unique2' (record only in second file).return type: text category_short Short category code: 'c' for common, 'u1' for unique1, 'u2' for unique2return type: text key The value of the compared key"},{"location":"cmp/#example","title":"Example","text":"<p>Compare two files by ID and sequence hash and store all commonly found records in a new file (some statistics is printed to STDERR):: <pre><code>st cmp input1.fasta input2.fasta --common1 common.fasta\n</code></pre> <pre><code>common  942\nunique1  51\nunique2  18\n</code></pre></p>"},{"location":"comparison/","title":"Comparison of tools","text":"<p>In the following list, we show the execution time, memory footprint and CPU usage of seqtool v0.4.0-beta on a selection of tasks, compared with the following tools:</p> <ul> <li>Seqtk v1.4</li> <li>SeqKit v2.7.0</li> <li>FASTX-Toolkit</li> <li>USEARCH v11.0.667</li> <li>VSEARCH v2.28.1</li> <li>Cutadapt v4.6</li> </ul> <p>Details on the approach are found here. The input file is a FASTQ or FASTA file containing 2.6 M reads (Illumina MiSeq, 300 bp). The comparison was run on a Ryzen 4750U CPU with frequency boost disabled, writing files to a RAM instead of the disk.</p> <p>The fastest/most memory-efficient commands are highlighted by '\ud83c\udfc6' and an indication, how many times faster / less memory they use compared to the commands ranking second. To show more details, click on the alternative commands list.</p>"},{"location":"comparison/#pass","title":"pass","text":"Do nothing, just read and write FASTA   <pre><code>st pass input.fasta &gt; output.fasta\n</code></pre> SeqKit \ud83d\udd53\u00a02.2\u00a0s\u00a0\ud83c\udfc6 (1.2x) SeqKit <pre><code>seqkit seq  input.fasta &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a02.2\u00a0s\u00a0\ud83c\udfc6 (1.2x) 106%\u00a0CPU\ud83d\udcc8\u00a018.0\u00a0MiB \ud83d\udd53\u00a02.6\u00a0s\ud83d\udcc8\u00a07.1\u00a0MiB\u00a0\ud83c\udfc6 (2.53x)   Convert FASTQ to FASTA   <pre><code>st pass --to-fa input.fastq &gt; output.fasta\n</code></pre> FASTX-Toolkit \ud83d\udd53\u00a0287.9\u00a0s\u00a0\u00a0\u2759  Seqtk \ud83d\udd53\u00a04.3\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a03.1\u00a0s FASTX-Toolkit <pre><code>fastq_to_fasta -Q33 -i input.fastq &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a0287.9\u00a0s\ud83d\udcc8\u00a03.5\u00a0MiB\u00a0\ud83c\udfc6 (1.00x) Seqtk <pre><code>seqtk seq -A input.fastq &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a04.3\u00a0s\ud83d\udcc8\u00a03.5\u00a0MiB SeqKit <pre><code>seqkit fq2fa input.fastq &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a03.1\u00a0s\ud83d\udcc8\u00a018.4\u00a0MiB \ud83d\udd53\u00a03.1\u00a0s\u00a0\ud83c\udfc6 (1.0x)\ud83d\udcc8\u00a07.1\u00a0MiB   Convert FASTQ quality scores   <pre><code>st pass --to fastq-illumina input.fastq &gt; output.fastq\n</code></pre> VSEARCH \ud83d\udd53\u00a012.9\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a048.8\u00a0s VSEARCH <pre><code>vsearch --fastq_convert input.fastq --fastq_asciiout 64 --fastqout output.fastq\n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nReading FASTQ file 100%\n</code></pre> \ud83d\udd53\u00a012.9\u00a0s\ud83d\udcc8\u00a04.2\u00a0MiB\u00a0\ud83c\udfc6 (1.65x) SeqKit <pre><code>seqkit convert --from 'Sanger' --to 'Illumina-1.3+' input.fastq &gt; output.fastq\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m converting Sanger -&gt; Illumina-1.3+\n</code></pre> \ud83d\udd53\u00a048.8\u00a0s\ud83d\udcc8\u00a047.9\u00a0MiB \ud83d\udd53\u00a07.4\u00a0s\u00a0\ud83c\udfc6 (1.8x)\ud83d\udcc8\u00a07.0\u00a0MiB   Write compressed FASTQ files in GZIP format   <pre><code>st pass input.fastq -o output.fastq.gz\n</code></pre> SeqKit \ud83d\udd53\u00a030.3\u00a0s\u00a0\ud83c\udfc6 (1.3x)\u00a0\u00a0\u2759  seqtool | gzip \ud83d\udd53\u00a0159.1\u00a0s\u00a0\u00a0\u2759  gzip directly \ud83d\udd53\u00a0158.6\u00a0s\u00a0\u00a0\u2759  pigz directly (4 threads) \ud83d\udd53\u00a039.0\u00a0s SeqKit <pre><code>seqkit seq input.fastq -o output.fastq.gz\n</code></pre> \ud83d\udd53\u00a030.3\u00a0s\u00a0\ud83c\udfc6 (1.3x)\ud83d\udcc8\u00a037.5\u00a0MiB seqtool | gzip <pre><code>st pass input.fastq | gzip -c &gt; output.fastq.gz\n</code></pre> \ud83d\udd53\u00a0159.1\u00a0s\ud83d\udcc8\u00a07.2\u00a0MiB gzip directly <pre><code>gzip -kf input.fastq\n</code></pre> \ud83d\udd53\u00a0158.6\u00a0s\ud83d\udcc8\u00a03.5\u00a0MiB\u00a0\ud83c\udfc6 (1.21x) pigz directly (4 threads) <pre><code>pigz -p4 -kf input.fastq\n</code></pre> \ud83d\udd53\u00a039.0\u00a0s 405%\u00a0CPU\ud83d\udcc8\u00a04.2\u00a0MiB \ud83d\udd53\u00a055.8\u00a0s\ud83d\udcc8\u00a027.5\u00a0MiB   Write compressed FASTQ files in Zstandard format   <pre><code>st pass input.fastq -o output.fastq.zst\n</code></pre> seqtool | zstd piped \ud83d\udd53\u00a012.8\u00a0s\u00a0\ud83c\udfc6 (1.2x) seqtool | zstd piped <pre><code>st pass input.fastq | zstd -c &gt; output.fastq.zst\n</code></pre> \ud83d\udd53\u00a012.8\u00a0s\u00a0\ud83c\udfc6 (1.2x) 147%\u00a0CPU\ud83d\udcc8\u00a038.8\u00a0MiB \ud83d\udd53\u00a015.5\u00a0s 114%\u00a0CPU\ud83d\udcc8\u00a011.0\u00a0MiB\u00a0\ud83c\udfc6 (3.52x)   Write compressed FASTQ files in Lz4 format   <pre><code>st pass input.fastq -o output.fastq.lz4\n</code></pre> seqtool | lz4 piped \ud83d\udd53\u00a09.9\u00a0s seqtool | lz4 piped <pre><code>st pass input.fastq | lz4 -c &gt; output.fastq.lz4\n</code></pre> \ud83d\udd53\u00a09.9\u00a0s 116%\u00a0CPU\ud83d\udcc8\u00a07.4\u00a0MiB\u00a0\ud83c\udfc6 (3.75x) \ud83d\udd53\u00a09.4\u00a0s\u00a0\ud83c\udfc6 (1.1x) 116%\u00a0CPU\ud83d\udcc8\u00a027.6\u00a0MiB"},{"location":"comparison/#count","title":"count","text":"Count the number of FASTQ sequences in the input   <pre><code>st count input.fastq\n</code></pre> \ud83d\udfe6\u00a0output <pre><code>2610480\n</code></pre> Seqtk \ud83d\udd53\u00a00.7\u00a0s Seqtk <pre><code>seqtk size input.fasta\n</code></pre> \ud83d\udfe6\u00a0output <pre><code>2610480 712939424\n</code></pre> \ud83d\udd53\u00a00.7\u00a0s\ud83d\udcc8\u00a03.4\u00a0MiB\u00a0\ud83c\udfc6 (2.11x) \ud83d\udd53\u00a00.6\u00a0s\u00a0\ud83c\udfc6 (1.2x)\ud83d\udcc8\u00a07.1\u00a0MiB   Count the number of FASTQ sequences, grouped by GC content (in 10% intervals)   <pre><code>st count -k 'bin(gc_percent, 10)' input.fastq\n</code></pre> \ud83d\udfe6\u00a0output <pre><code>(10, 20]    16\n(20, 30]    3004\n(30, 40]    51945\n(40, 50]    1149946\n(50, 60]    1248702\n(60, 70]    20439\n(70, 80]    120\n(80, 90]    63\n(90, 100]   37\n(100, 110]  11\n(NaN, NaN]  136197\n</code></pre> st with math expression \ud83d\udd53\u00a07.0\u00a0s st with math expression <pre><code>st count -k '{bin(gc_percent/100*100, 10)}' input.fastq\n</code></pre> \ud83d\udfe6\u00a0output <pre><code>(10, 20]    16\n(20, 30]    3004\n(30, 40]    51945\n(40, 50]    1149946\n(50, 60]    1248702\n(60, 70]    20439\n(70, 80]    120\n(80, 90]    63\n(90, 100]   37\n(100, 110]  11\n(NaN, NaN]  136197\n</code></pre> \ud83d\udd53\u00a07.0\u00a0s\ud83d\udcc8\u00a086.0\u00a0MiB \ud83d\udd53\u00a04.2\u00a0s\u00a0\ud83c\udfc6 (1.6x)\ud83d\udcc8\u00a07.4\u00a0MiB\u00a0\ud83c\udfc6 (11.66x)"},{"location":"comparison/#sort","title":"sort","text":"Sort by sequence   <pre><code>st sort seq input.fasta &gt; output.fasta\n</code></pre> SeqKit \ud83d\udd53\u00a042.3\u00a0s SeqKit <pre><code>seqkit sort -s  input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m read sequences ...\n[INFO]\u001b[0m 2610480 sequences loaded\n[INFO]\u001b[0m sorting ...\n[INFO]\u001b[0m output ...\n</code></pre> \ud83d\udd53\u00a042.3\u00a0s\ud83d\udcc8\u00a04595.1\u00a0MiB \ud83d\udd53\u00a013.6\u00a0s\u00a0\ud83c\udfc6 (3.1x)\ud83d\udcc8\u00a01771.4\u00a0MiB\u00a0\ud83c\udfc6 (2.59x)   Sort by sequence with ~ 50 MiB memory limit   <pre><code>st sort seq input.fasta -M 50M &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>Memory limit reached after 78050 records, writing to temporary file(s). Consider raising the limit (-M/--max-mem) to speed up sorting. Use -q/--quiet to silence this message.\n</code></pre> 100 MiB memory limit \ud83d\udd53\u00a020.6\u00a0s 100 MiB memory limit <pre><code>st sort seq input.fasta -M 100M &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>Memory limit reached after 155392 records, writing to temporary file(s). Consider raising the limit (-M/--max-mem) to speed up sorting. Use -q/--quiet to silence this message.\n</code></pre> \ud83d\udd53\u00a020.6\u00a0s\ud83d\udcc8\u00a0108.7\u00a0MiB \ud83d\udd53\u00a020.3\u00a0s\u00a0\ud83c\udfc6 (1.0x)\ud83d\udcc8\u00a058.5\u00a0MiB\u00a0\ud83c\udfc6 (1.86x)   Sort by record ID   <pre><code>st sort id input.fasta &gt; output.fasta\n</code></pre> SeqKit \ud83d\udd53\u00a034.2\u00a0s SeqKit <pre><code>seqkit sort  input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m read sequences ...\n[INFO]\u001b[0m 2610480 sequences loaded\n[INFO]\u001b[0m sorting ...\n[INFO]\u001b[0m output ...\n</code></pre> \ud83d\udd53\u00a034.2\u00a0s\ud83d\udcc8\u00a04436.4\u00a0MiB \ud83d\udd53\u00a06.5\u00a0s\u00a0\ud83c\udfc6 (5.3x)\ud83d\udcc8\u00a01119.2\u00a0MiB\u00a0\ud83c\udfc6 (3.96x)   Sort by sequence length   <pre><code>st sort seqlen input.fasta &gt; output.fasta\n</code></pre> SeqKit \ud83d\udd53\u00a033.7\u00a0s\u00a0\u00a0\u2759  VSEARCH \ud83d\udd53\u00a09.4\u00a0s SeqKit <pre><code>seqkit sort -l  input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m read sequences ...\n[INFO]\u001b[0m 2610480 sequences loaded\n[INFO]\u001b[0m sorting ...\n[INFO]\u001b[0m output ...\n</code></pre> \ud83d\udd53\u00a033.7\u00a0s\ud83d\udcc8\u00a04153.5\u00a0MiB VSEARCH <pre><code>vsearch --sortbylength input.fasta --output output.fasta \n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nReading file input.fasta 100%\n712939424 nt in 2610480 seqs, min 35, max 301, avg 273\nGetting lengths 100%\nSorting 100%\nMedian length: 301\nWriting output 100%\n</code></pre> \ud83d\udd53\u00a09.4\u00a0s\ud83d\udcc8\u00a0891.4\u00a0MiB\u00a0\ud83c\udfc6 (1.17x) \ud83d\udd53\u00a05.9\u00a0s\u00a0\ud83c\udfc6 (1.6x)\ud83d\udcc8\u00a01042.4\u00a0MiB   Sort sequences by USEARCH/VSEARCH-style abundance annotations   <pre><code>ST_ATTR_FMT=';key=value' st unique seq -a size={n_duplicates} input.fasta |\n  st sort '{-attr(\"size\")}' &gt; output.fasta\n</code></pre> VSEARCH \ud83d\udd53\u00a020.4\u00a0s VSEARCH <pre><code>vsearch --derep_fulllength input.fasta --output - --sizeout |   vsearch --sortbysize - --output output.fasta  \n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nvsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nDereplicating file input.fasta 100%\n712939424 nt in 2610480 seqs, min 35, max 301, avg 273\nSorting 100%\n2134929 unique sequences, avg cluster 1.2, median 1, max 136182\nWriting FASTA output fileReading file - 100%\n 100%\n606287856 nt in 2134929 seqs, min 35, max 301, avg 284\nGetting sizes 100%\nSorting 100%\nMedian abundance: 1\nWriting output 100%\n</code></pre> \ud83d\udd53\u00a020.4\u00a0s 113%\u00a0CPU\ud83d\udcc8\u00a01345.8\u00a0MiB\u00a0\ud83c\udfc6 (1.19x) \ud83d\udd53\u00a013.3\u00a0s\u00a0\ud83c\udfc6 (1.5x) 110%\u00a0CPU\ud83d\udcc8\u00a01606.5\u00a0MiB"},{"location":"comparison/#unique","title":"unique","text":"Remove duplicate sequences using sequence hashes. This is more memory efficient and usually faster than keeping the whole  sequence around.    <pre><code>st unique seqhash input.fasta &gt; output.fasta\n</code></pre> SeqKit \ud83d\udd53\u00a03.3\u00a0s\u00a0\ud83c\udfc6 (1.2x) SeqKit <pre><code>seqkit rmdup -sP  input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m 475551 duplicated records removed\n</code></pre> \ud83d\udd53\u00a03.3\u00a0s\u00a0\ud83c\udfc6 (1.2x)\ud83d\udcc8\u00a0180.1\u00a0MiB \ud83d\udd53\u00a04.2\u00a0s\ud83d\udcc8\u00a0117.1\u00a0MiB\u00a0\ud83c\udfc6 (1.54x)   Remove duplicate sequences using sequence hashes (case-insensitive).    <pre><code>st unique 'seqhash(true)' input.fasta &gt; output.fasta\n</code></pre> VSEARCH \ud83d\udd53\u00a012.1\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a06.2\u00a0s VSEARCH <pre><code>vsearch --derep_smallmem input.fasta --fastaout output.fasta \n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nDereplicating file input.fasta 100%\n712939424 nt in 2610480 seqs, min 35, max 301, avg 273\n2134929 unique sequences, avg cluster 1.2, median 1, max 136182\nWriting FASTA output file 100%\n</code></pre> \ud83d\udd53\u00a012.1\u00a0s\ud83d\udcc8\u00a090.7\u00a0MiB\u00a0\ud83c\udfc6 (1.29x) SeqKit <pre><code>seqkit rmdup -sPi  input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m 475551 duplicated records removed\n</code></pre> \ud83d\udd53\u00a06.2\u00a0s\ud83d\udcc8\u00a0289.8\u00a0MiB \ud83d\udd53\u00a04.3\u00a0s\u00a0\ud83c\udfc6 (1.4x)\ud83d\udcc8\u00a0117.2\u00a0MiB   Remove duplicate sequences that are exactly identical (case-insensitive); comparing full sequences instead of not hashes (requires more memory). VSEARCH additionally treats 'T' and 'U' in the same way (seqtool doesn't).    <pre><code>st unique upper_seq input.fasta &gt; output.fasta\n</code></pre> seqtool (sorted by sequence) \ud83d\udd53\u00a013.5\u00a0s\u00a0\u00a0\u2759  VSEARCH \ud83d\udd53\u00a015.8\u00a0s seqtool (sorted by sequence) <pre><code>st unique -s upper_seq input.fasta &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a013.5\u00a0s\ud83d\udcc8\u00a01640.7\u00a0MiB VSEARCH <pre><code>vsearch --derep_fulllength input.fasta --output output.fasta \n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nDereplicating file input.fasta 100%\n712939424 nt in 2610480 seqs, min 35, max 301, avg 273\nSorting 100%\n2134929 unique sequences, avg cluster 1.2, median 1, max 136182\nWriting FASTA output file 100%\n</code></pre> \ud83d\udd53\u00a015.8\u00a0s\ud83d\udcc8\u00a01345.7\u00a0MiB \ud83d\udd53\u00a05.4\u00a0s\u00a0\ud83c\udfc6 (2.5x)\ud83d\udcc8\u00a0729.0\u00a0MiB\u00a0\ud83c\udfc6 (1.85x)   Remove duplicate sequences (exact mode) with a memory limit of ~50 MiB   <pre><code>st unique seq -M 50M input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>Memory limit reached after 151512 records, writing to temporary file(s). Consider raising the limit (-M/--max-mem) to speed up de-duplicating. Use -q/--quiet to silence this message.\n</code></pre> \ud83d\udd53\u00a019.5\u00a0s\ud83d\udcc8\u00a056.6\u00a0MiB   Remove duplicate sequences, checking both strands   <pre><code>st unique seqhash_both input.fasta &gt; output.fasta\n</code></pre> SeqKit \ud83d\udd53\u00a014.8\u00a0s SeqKit <pre><code>seqkit rmdup -s  input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m 475687 duplicated records removed\n</code></pre> \ud83d\udd53\u00a014.8\u00a0s\ud83d\udcc8\u00a0293.6\u00a0MiB \ud83d\udd53\u00a07.5\u00a0s\u00a0\ud83c\udfc6 (2.0x)\ud83d\udcc8\u00a0117.1\u00a0MiB\u00a0\ud83c\udfc6 (2.51x)   Remove duplicate sequences, appending USEARCH/VSEARCH-style abundance annotations to the headers: &gt;id;size=NN <pre><code>st unique seq -a size={n_duplicates} --attr-fmt ';key=value' input.fasta &gt; output.fasta\n</code></pre> VSEARCH \ud83d\udd53\u00a016.1\u00a0s VSEARCH <pre><code>vsearch --derep_fulllength input.fasta --sizeout --output output.fasta \n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nDereplicating file input.fasta 100%\n712939424 nt in 2610480 seqs, min 35, max 301, avg 273\nSorting 100%\n2134929 unique sequences, avg cluster 1.2, median 1, max 136182\nWriting FASTA output file 100%\n</code></pre> \ud83d\udd53\u00a016.1\u00a0s\ud83d\udcc8\u00a01345.9\u00a0MiB\u00a0\ud83c\udfc6 (1.19x) \ud83d\udd53\u00a09.3\u00a0s\u00a0\ud83c\udfc6 (1.7x)\ud83d\udcc8\u00a01606.2\u00a0MiB   De-replicate both by sequence and record ID (the part before the first space in the header). The given benchmark actually has unique sequence IDs, so the result is the same as de-replication by sequence.    <pre><code>st unique id,seq input.fasta &gt; output.fasta\n</code></pre> VSEARCH \ud83d\udd53\u00a017.7\u00a0s VSEARCH <pre><code>vsearch --derep_id input.fasta --output output.fasta\n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nDereplicating file input.fasta 100%\n712939424 nt in 2610480 seqs, min 35, max 301, avg 273\nSorting 100%\n2610480 unique sequences, avg cluster 1.0, median 1, max 1\nWriting FASTA output file 100%\n</code></pre> \ud83d\udd53\u00a017.7\u00a0s\ud83d\udcc8\u00a01364.4\u00a0MiB \ud83d\udd53\u00a07.5\u00a0s\u00a0\ud83c\udfc6 (2.3x)\ud83d\udcc8\u00a01090.6\u00a0MiB\u00a0\ud83c\udfc6 (1.25x)"},{"location":"comparison/#filter","title":"filter","text":"Filter sequences by length   <pre><code>st filter 'seqlen &gt;= 100' input.fastq &gt; output.fastq\n</code></pre> Seqtk \ud83d\udd53\u00a06.5\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a04.1\u00a0s\u00a0\ud83c\udfc6 (1.3x) Seqtk <pre><code>seqtk seq -L 100 input.fastq &gt; output.fastq\n</code></pre> \ud83d\udd53\u00a06.5\u00a0s\ud83d\udcc8\u00a03.5\u00a0MiB\u00a0\ud83c\udfc6 (2.07x) SeqKit <pre><code>seqkit seq -m 100 input.fastq &gt; output.fastq\n</code></pre> \u00a0messages <pre><code>\u001b[33m[WARN]\u001b[0m you may switch on flag -g/--remove-gaps to remove spaces\n</code></pre> \ud83d\udd53\u00a04.1\u00a0s\u00a0\ud83c\udfc6 (1.3x)\ud83d\udcc8\u00a028.1\u00a0MiB \ud83d\udd53\u00a05.4\u00a0s\ud83d\udcc8\u00a07.2\u00a0MiB   Filter sequences by the total expected error as calculated from the quality scores    <pre><code>st filter 'exp_err &lt;= 1' input.fastq --to-fa &gt; output.fastq\n</code></pre> VSEARCH \ud83d\udd53\u00a032.9\u00a0s\u00a0\u00a0\u2759  USEARCH \ud83d\udd53\u00a016.0\u00a0s\u00a0\ud83c\udfc6 (1.7x) VSEARCH <pre><code>vsearch --fastq_filter input.fastq --fastq_maxee 1 --fastaout output.fasta \n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nReading input file 100%\n1408755 sequences kept (of which 0 truncated), 1201725 sequences discarded.\n</code></pre> \ud83d\udd53\u00a032.9\u00a0s\ud83d\udcc8\u00a04.4\u00a0MiB\u00a0\ud83c\udfc6 (1.66x) USEARCH <pre><code>usearch -fastq_filter input.fastq -fastq_maxee 1 -fastaout output.fasta\n</code></pre> \ud83d\udfe6\u00a0output <pre><code>usearch v11.0.667_i86linux32, 4.0Gb RAM (32.1Gb total), 16 cores\n(C) Copyright 2013-18 Robert C. Edgar, all rights reserved.\nhttps://drive5.com/usearch\nLicense: personal use only\n</code></pre> \u00a0messages <pre><code>00:00 4.2Mb  FASTQ base 33 for file input.fastq\n00:00 38Mb   CPU has 16 cores, defaulting to 10 threads\n00:00 115Mb     0.1% Filtering\n00:01 123Mb     1.0% Filtering, 31.4% passed\n00:02 123Mb     8.7% Filtering, 31.5% passed\n00:03 123Mb    16.4% Filtering, 31.8% passed\n00:04 123Mb    22.1% Filtering, 40.1% passed\n00:05 123Mb    26.7% Filtering, 47.6% passed\n00:06 123Mb    31.5% Filtering, 52.6% passed\n00:07 123Mb    36.4% Filtering, 56.2% passed\n00:08 123Mb    41.3% Filtering, 59.1% passed\n00:09 123Mb    47.2% Filtering, 60.1% passed\n00:10 123Mb    53.5% Filtering, 60.1% passed\n00:11 123Mb    61.1% Filtering, 56.6% passed\n00:12 123Mb    68.7% Filtering, 53.5% passed\n00:13 123Mb    75.4% Filtering, 53.7% passed\n00:14 123Mb    83.4% Filtering, 51.4% passed\n00:15 123Mb    89.4% Filtering, 52.2% passed\n00:16 123Mb    95.1% Filtering, 53.2% passed\n00:16 90Mb    100.0% Filtering, 54.0% passed\n   2610480  Reads (2.6M)\n   1201725  Discarded reads with expected errs &gt; 1.00\n   1408755  Filtered reads (1.4M, 54.0%)\n</code></pre> \ud83d\udd53\u00a016.0\u00a0s\u00a0\ud83c\udfc6 (1.7x) 997%\u00a0CPU\ud83d\udcc8\u00a034.9\u00a0MiB \ud83d\udd53\u00a027.9\u00a0s\ud83d\udcc8\u00a07.2\u00a0MiB   Select records from a large set of sequences given a list of 1000 sequence IDs   <pre><code>st filter -m ids_list.txt 'has_meta()' input.fasta &gt; output.fasta\n</code></pre> VSEARCH \ud83d\udd53\u00a028.1\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a01.0\u00a0s\u00a0\ud83c\udfc6 (1.6x) VSEARCH <pre><code>vsearch --fastx_getseqs input.fasta --labels ids_list.txt --fastaout output.fasta\n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nReading labels 100%\nExtracting sequences 100%\n1000 of 2610480 sequences extracted (0.0%)\n</code></pre> \ud83d\udd53\u00a028.1\u00a0s\ud83d\udcc8\u00a04.2\u00a0MiB\u00a0\ud83c\udfc6 (1.85x) SeqKit <pre><code>seqkit grep -f ids_list.txt input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m 1000 patterns loaded from file\n</code></pre> \ud83d\udd53\u00a01.0\u00a0s\u00a0\ud83c\udfc6 (1.6x)\ud83d\udcc8\u00a021.8\u00a0MiB \ud83d\udd53\u00a01.6\u00a0s\ud83d\udcc8\u00a07.9\u00a0MiB"},{"location":"comparison/#sample","title":"sample","text":"Random subsampling to 1000 of sequences   <pre><code>st sample -n 1000 input.fasta &gt; output.fasta\n</code></pre> VSEARCH \ud83d\udd53\u00a04.3\u00a0s\u00a0\u00a0\u2759  Seqtk \ud83d\udd53\u00a00.8\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a011.5\u00a0s VSEARCH <pre><code>vsearch --fastx_subsample input.fasta --sample_size 1000 --fastaout output.fasta\n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nReading file input.fasta 100%\n712939424 nt in 2610480 seqs, min 35, max 301, avg 273\nGot 2610480 reads from 2610480 amplicons\nSubsampling 100%\nWriting output 100%\nSubsampled 1000 reads from 1000 amplicons\n</code></pre> \ud83d\udd53\u00a04.3\u00a0s\ud83d\udcc8\u00a0841.5\u00a0MiB Seqtk <pre><code>seqtk sample input.fasta 1000 &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a00.8\u00a0s\ud83d\udcc8\u00a03.5\u00a0MiB\u00a0\ud83c\udfc6 (2.07x) SeqKit <pre><code>seqkit sample -n 1000 input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m sample by number\n[INFO]\u001b[0m loading all sequences into memory...\n[INFO]\u001b[0m 1000 sequences outputted\n</code></pre> \ud83d\udd53\u00a011.5\u00a0s\ud83d\udcc8\u00a03112.7\u00a0MiB \ud83d\udd53\u00a00.5\u00a0s\u00a0\ud83c\udfc6 (1.4x)\ud83d\udcc8\u00a07.2\u00a0MiB   Random subsampling to ~10% of sequences   <pre><code>st sample -p 0.1 input.fasta &gt; output.fasta\n</code></pre> Seqtk \ud83d\udd53\u00a01.7\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a02.0\u00a0s Seqtk <pre><code>seqtk sample input.fastq 0.1 &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a01.7\u00a0s\ud83d\udcc8\u00a03.5\u00a0MiB\u00a0\ud83c\udfc6 (2.04x) SeqKit <pre><code>seqkit sample -p 0.1 input.fastq &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m sample by proportion\n[INFO]\u001b[0m 260463 sequences outputted\n</code></pre> \ud83d\udd53\u00a02.0\u00a0s\ud83d\udcc8\u00a027.6\u00a0MiB \ud83d\udd53\u00a00.8\u00a0s\u00a0\ud83c\udfc6 (2.2x)\ud83d\udcc8\u00a07.1\u00a0MiB"},{"location":"comparison/#find","title":"find","text":"Find the forward primer location in the input reads with up to 4 mismatches   <pre><code>st find -D4 file:primers.fasta input.fastq -a primer={pattern_name} -a rng={match_range} &gt; output.fastq\n</code></pre> \u00a0messages <pre><code>Note: the sequence type of the pattern 'ITS4' was determined as 'dna'. If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> st (4 threads) \ud83d\udd53\u00a06.0\u00a0s\u00a0\ud83c\udfc6 (3.5x)\u00a0\u00a0\u2759  st (max. mismatches = 2) \ud83d\udd53\u00a021.1\u00a0s\u00a0\u00a0\u2759  st (max. mismatches = 8) \ud83d\udd53\u00a026.7\u00a0s st (4 threads) <pre><code>st find -t4 -D4 file:primers.fasta input.fastq -a primer={pattern_name} -a rng={match_range} &gt; output.fastq\n</code></pre> \u00a0messages <pre><code>Note: the sequence type of the pattern 'ITS4' was determined as 'dna'. If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> \ud83d\udd53\u00a06.0\u00a0s\u00a0\ud83c\udfc6 (3.5x) 402%\u00a0CPU\ud83d\udcc8\u00a017.6\u00a0MiB st (max. mismatches = 2) <pre><code>st find -D2 file:primers.fasta input.fastq -a primer={pattern_name} -a rng={match_range} &gt; output.fastq\n</code></pre> \u00a0messages <pre><code>Note: the sequence type of the pattern 'ITS4' was determined as 'dna'. If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> \ud83d\udd53\u00a021.1\u00a0s\ud83d\udcc8\u00a07.5\u00a0MiB st (max. mismatches = 8) <pre><code>st find -D8 file:primers.fasta input.fastq -a primer={pattern_name} -a rng={match_range} &gt; output.fastq\n</code></pre> \u00a0messages <pre><code>Note: the sequence type of the pattern 'ITS4' was determined as 'dna'. If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> \ud83d\udd53\u00a026.7\u00a0s\ud83d\udcc8\u00a07.4\u00a0MiB \ud83d\udd53\u00a021.3\u00a0s\ud83d\udcc8\u00a07.4\u00a0MiB\u00a0\ud83c\udfc6 (1.00x)   Find and trim the forward primer up to an error rate (edit distance) of 20%, discarding unmatched reads. Note: Unlike Cutadapt, seqtool currently does not offer ungapped alignments (<code>--no-indels</code>).    <pre><code>st find -f file:primers.fasta -R 0.2 input.fastq -a primer={pattern_name} -a end={match_end} |\n  st trim -e '{attr(end)}:' --fq &gt; output.fastq\n</code></pre> \u00a0messages <pre><code>Note: the sequence type of the pattern 'ITS4' was determined as 'dna'. If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> Cutadapt \ud83d\udd53\u00a067.1\u00a0s Cutadapt <pre><code>cutadapt -g 'file:primers.fasta;min_overlap=15' input.fastq -e 0.2 --rename '{id} primer={adapter_name}' --discard-untrimmed &gt; output.fastq \n</code></pre> \u00a0messages <pre><code>This is cutadapt 4.6 with Python 3.12.2\nCommand line parameters: -g file:primers.fasta;min_overlap=15 input.fastq -e 0.2 --rename {id} primer={adapter_name} --discard-untrimmed\nProcessing single-end reads on 1 core ...\nFinished in 66.906 s (25.630 \u00b5s/read; 2.34 M reads/minute).\n=== Summary ===\nTotal reads processed:               2,610,480\nReads with adapters:                   828,740 (31.7%)\n== Read fate breakdown ==\nReads discarded as untrimmed:        1,781,740 (68.3%)\nReads written (passing filters):       828,740 (31.7%)\nTotal basepairs processed:   712,939,424 bp\nTotal written (filtered):    209,047,405 bp (29.3%)\n=== Adapter ITS4 ===\nSequence: GTCCTCCGCTTATTGATATGC; Type: regular 5'; Length: 21; Trimmed: 828740 times\nMinimum overlap: 15\nNo. of allowed errors:\n1-4 bp: 0; 5-9 bp: 1; 10-14 bp: 2; 15-19 bp: 3; 20-21 bp: 4\nOverview of removed sequences\nlength  count   expect  max.err error counts\n15  8   0.0 3   3 1 3 1\n16  12  0.0 3   1 3 4 4\n17  7   0.0 3   3 0 0 4\n18  11  0.0 3   2 6 1 2\n19  12  0.0 3   1 2 6 1 2\n20  15  0.0 4   3 5 3 2 2\n21  29  0.0 4   2 11 4 2 10\n22  73  0.0 4   5 23 8 15 22\n23  221 0.0 4   10 46 39 53 73\n24  723 0.0 4   27 96 180 381 39\n25  8858    0.0 4   439 2961 4797 468 193\n26  816649  0.0 4   202089 581641 27831 3348 1740\n27  1926    0.0 4   184 840 797 74 31\n28  33  0.0 4   4 22 2 3 2\n29  15  0.0 4   1 11 1 1 1\n30  4   0.0 4   1 3\n31  1   0.0 4   1\n32  3   0.0 4   2 1\n33  1   0.0 4   1\n34  1   0.0 4   1\n35  2   0.0 4   0 2\n40  2   0.0 4   0 2\n41  2   0.0 4   0 2\n42  3   0.0 4   1 2\n45  1   0.0 4   0 1\n47  1   0.0 4   0 0 0 0 1\n48  1   0.0 4   1\n51  6   0.0 4   0 0 0 0 6\n54  1   0.0 4   0 0 0 0 1\n58  16  0.0 4   0 0 0 0 16\n59  2   0.0 4   0 1 0 0 1\n60  2   0.0 4   0 0 0 0 2\n61  20  0.0 4   0 1 0 0 19\n62  1   0.0 4   0 0 0 0 1\n63  12  0.0 4   0 1 0 1 10\n64  2   0.0 4   0 0 0 0 2\n66  2   0.0 4   0 0 0 1 1\n67  24  0.0 4   0 0 3 5 16\n68  4   0.0 4   0 0 1 0 3\n69  1   0.0 4   0 0 0 0 1\n85  2   0.0 4   0 2\n86  5   0.0 4   1 3 0 0 1\n105 4   0.0 4   0 0 0 0 4\n138 1   0.0 4   0 0 0 0 1\n190 2   0.0 4   0 0 0 0 2\n203 1   0.0 4   0 0 0 0 1\n226 2   0.0 4   0 0 0 0 2\n227 1   0.0 4   0 0 0 0 1\n228 3   0.0 4   0 0 0 0 3\n230 1   0.0 4   0 0 0 0 1\n247 1   0.0 4   0 0 0 0 1\n249 1   0.0 4   0 0 0 0 1\n251 5   0.0 4   0 0 0 0 5\n252 1   0.0 4   0 0 0 0 1\n255 1   0.0 4   0 0 0 0 1\n258 1   0.0 4   0 0 0 0 1\n290 1   0.0 4   0 0 0 0 1\n</code></pre> \ud83d\udd53\u00a067.1\u00a0s\ud83d\udcc8\u00a020.9\u00a0MiB \ud83d\udd53\u00a016.9\u00a0s\u00a0\ud83c\udfc6 (4.0x) 120%\u00a0CPU\ud83d\udcc8\u00a07.4\u00a0MiB\u00a0\ud83c\udfc6 (2.83x)   Find and trim the forward primer in parallel using 4 threads (cores).    <pre><code>st find -f file:primers.fasta -R 0.2 -t4 input.fastq -a primer={pattern_name} -a end={match_end} |\n  st trim -e '{attr(end)}:' --fq &gt; output.fastq\n</code></pre> \u00a0messages <pre><code>Note: the sequence type of the pattern 'ITS4' was determined as 'dna'. If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> Cutadapt \ud83d\udd53\u00a018.1\u00a0s Cutadapt <pre><code>cutadapt -j4 -g 'file:primers.fasta;min_overlap=15' input.fastq -e 0.2 --rename '{id} primer={adapter_name}' --discard-untrimmed &gt; output.fastq \n</code></pre> \u00a0messages <pre><code>This is cutadapt 4.6 with Python 3.12.2\nCommand line parameters: -j4 -g file:primers.fasta;min_overlap=15 input.fastq -e 0.2 --rename {id} primer={adapter_name} --discard-untrimmed\nProcessing single-end reads on 4 cores ...\nFinished in 17.956 s (6.878 \u00b5s/read; 8.72 M reads/minute).\n=== Summary ===\nTotal reads processed:               2,610,480\nReads with adapters:                   828,740 (31.7%)\n== Read fate breakdown ==\nReads discarded as untrimmed:        1,781,740 (68.3%)\nReads written (passing filters):       828,740 (31.7%)\nTotal basepairs processed:   712,939,424 bp\nTotal written (filtered):    209,047,405 bp (29.3%)\n=== Adapter ITS4 ===\nSequence: GTCCTCCGCTTATTGATATGC; Type: regular 5'; Length: 21; Trimmed: 828740 times\nMinimum overlap: 15\nNo. of allowed errors:\n1-4 bp: 0; 5-9 bp: 1; 10-14 bp: 2; 15-19 bp: 3; 20-21 bp: 4\nOverview of removed sequences\nlength  count   expect  max.err error counts\n15  8   0.0 3   3 1 3 1\n16  12  0.0 3   1 3 4 4\n17  7   0.0 3   3 0 0 4\n18  11  0.0 3   2 6 1 2\n19  12  0.0 3   1 2 6 1 2\n20  15  0.0 4   3 5 3 2 2\n21  29  0.0 4   2 11 4 2 10\n22  73  0.0 4   5 23 8 15 22\n23  221 0.0 4   10 46 39 53 73\n24  723 0.0 4   27 96 180 381 39\n25  8858    0.0 4   439 2961 4797 468 193\n26  816649  0.0 4   202089 581641 27831 3348 1740\n27  1926    0.0 4   184 840 797 74 31\n28  33  0.0 4   4 22 2 3 2\n29  15  0.0 4   1 11 1 1 1\n30  4   0.0 4   1 3\n31  1   0.0 4   1\n32  3   0.0 4   2 1\n33  1   0.0 4   1\n34  1   0.0 4   1\n35  2   0.0 4   0 2\n40  2   0.0 4   0 2\n41  2   0.0 4   0 2\n42  3   0.0 4   1 2\n45  1   0.0 4   0 1\n47  1   0.0 4   0 0 0 0 1\n48  1   0.0 4   1\n51  6   0.0 4   0 0 0 0 6\n54  1   0.0 4   0 0 0 0 1\n58  16  0.0 4   0 0 0 0 16\n59  2   0.0 4   0 1 0 0 1\n60  2   0.0 4   0 0 0 0 2\n61  20  0.0 4   0 1 0 0 19\n62  1   0.0 4   0 0 0 0 1\n63  12  0.0 4   0 1 0 1 10\n64  2   0.0 4   0 0 0 0 2\n66  2   0.0 4   0 0 0 1 1\n67  24  0.0 4   0 0 3 5 16\n68  4   0.0 4   0 0 1 0 3\n69  1   0.0 4   0 0 0 0 1\n85  2   0.0 4   0 2\n86  5   0.0 4   1 3 0 0 1\n105 4   0.0 4   0 0 0 0 4\n138 1   0.0 4   0 0 0 0 1\n190 2   0.0 4   0 0 0 0 2\n203 1   0.0 4   0 0 0 0 1\n226 2   0.0 4   0 0 0 0 2\n227 1   0.0 4   0 0 0 0 1\n228 3   0.0 4   0 0 0 0 3\n230 1   0.0 4   0 0 0 0 1\n247 1   0.0 4   0 0 0 0 1\n249 1   0.0 4   0 0 0 0 1\n251 5   0.0 4   0 0 0 0 5\n252 1   0.0 4   0 0 0 0 1\n255 1   0.0 4   0 0 0 0 1\n258 1   0.0 4   0 0 0 0 1\n290 1   0.0 4   0 0 0 0 1\n</code></pre> \ud83d\udd53\u00a018.1\u00a0s 413%\u00a0CPU\ud83d\udcc8\u00a039.4\u00a0MiB \ud83d\udd53\u00a04.9\u00a0s\u00a0\ud83c\udfc6 (3.7x) 448%\u00a0CPU\ud83d\udcc8\u00a017.8\u00a0MiB\u00a0\ud83c\udfc6 (2.22x)"},{"location":"comparison/#replace","title":"replace","text":"Convert DNA to RNA using the replace command   <pre><code>st replace T U input.fasta &gt; output.fasta\n</code></pre> st find \ud83d\udd53\u00a014.3\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a04.8\u00a0s\u00a0\ud83c\udfc6 (2.1x)\u00a0\u00a0\u2759  FASTX-Toolkit \ud83d\udd53\u00a0283.5\u00a0s st find <pre><code>st find T --rep U input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>Note: the sequence type of the pattern was determined as 'dna'. If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> \ud83d\udd53\u00a014.3\u00a0s\ud83d\udcc8\u00a07.2\u00a0MiB SeqKit <pre><code>seqkit seq --dna2rna  input.fasta &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a04.8\u00a0s\u00a0\ud83c\udfc6 (2.1x)\ud83d\udcc8\u00a027.3\u00a0MiB FASTX-Toolkit <pre><code>fasta_nucleotide_changer -r -i input.fasta &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a0283.5\u00a0s\ud83d\udcc8\u00a03.5\u00a0MiB\u00a0\ud83c\udfc6 (2.07x) \ud83d\udd53\u00a010.1\u00a0s\ud83d\udcc8\u00a07.2\u00a0MiB   Convert DNA to RNA using 4 threads   <pre><code>st replace -t4 T U input.fasta &gt; output.fasta\n</code></pre> st find \ud83d\udd53\u00a08.4\u00a0s st find <pre><code>st find -t4 T --rep U input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>Note: the sequence type of the pattern was determined as 'dna'. If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> \ud83d\udd53\u00a08.4\u00a0s 282%\u00a0CPU\ud83d\udcc8\u00a024.6\u00a0MiB \ud83d\udd53\u00a02.7\u00a0s\u00a0\ud83c\udfc6 (3.1x) 418%\u00a0CPU\ud83d\udcc8\u00a09.0\u00a0MiB\u00a0\ud83c\udfc6 (2.74x)"},{"location":"comparison/#trim","title":"trim","text":"Trim the leading 99 bp from the sequences   <pre><code>st trim 100: input.fasta &gt; output.fasta\n</code></pre> SeqKit (creates FASTA index) \ud83d\udd53\u00a044.8\u00a0s SeqKit (creates FASTA index) <pre><code>seqkit subseq -r '100:-1'  input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>[INFO]\u001b[0m create or read FASTA index ...\n[INFO]\u001b[0m create FASTA index for input.fasta\n[INFO]\u001b[0m   2610480 records loaded from input.fasta.seqkit.fai\n</code></pre> \ud83d\udd53\u00a044.8\u00a0s\ud83d\udcc8\u00a01254.5\u00a0MiB \ud83d\udd53\u00a02.8\u00a0s\u00a0\ud83c\udfc6 (16.0x)\ud83d\udcc8\u00a07.4\u00a0MiB\u00a0\ud83c\udfc6 (170.10x)"},{"location":"comparison/#upper","title":"upper","text":"Convert sequences to uppercase   <pre><code>st upper input.fasta &gt; output.fasta\n</code></pre> Seqtk \ud83d\udd53\u00a05.2\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a04.2\u00a0s Seqtk <pre><code>seqtk seq -U input.fasta &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a05.2\u00a0s\ud83d\udcc8\u00a03.5\u00a0MiB\u00a0\ud83c\udfc6 (2.11x) SeqKit <pre><code>seqkit seq -u  input.fasta &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a04.2\u00a0s\ud83d\udcc8\u00a062.2\u00a0MiB \ud83d\udd53\u00a03.0\u00a0s\u00a0\ud83c\udfc6 (1.4x)\ud83d\udcc8\u00a07.4\u00a0MiB"},{"location":"comparison/#revcomp","title":"revcomp","text":"Reverse complement sequences   <pre><code>st revcomp input.fasta &gt; output.fasta\n</code></pre> Seqtk \ud83d\udd53\u00a05.3\u00a0s\u00a0\ud83c\udfc6 (1.1x)\u00a0\u00a0\u2759  VSEARCH \ud83d\udd53\u00a07.7\u00a0s\u00a0\u00a0\u2759  SeqKit \ud83d\udd53\u00a07.8\u00a0s Seqtk <pre><code>seqtk seq -r input.fasta &gt; output.fasta\n</code></pre> \ud83d\udd53\u00a05.3\u00a0s\u00a0\ud83c\udfc6 (1.1x)\ud83d\udcc8\u00a03.5\u00a0MiB\u00a0\ud83c\udfc6 (1.21x) VSEARCH <pre><code>vsearch --fastx_revcomp input.fasta --fastaout output.fasta \n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nReading FASTA file 100%\n</code></pre> \ud83d\udd53\u00a07.7\u00a0s\ud83d\udcc8\u00a04.2\u00a0MiB SeqKit <pre><code>seqkit seq -rp  input.fasta &gt; output.fasta\n</code></pre> \u00a0messages <pre><code>\u001b[33m[WARN]\u001b[0m flag -t (--seq-type) (DNA/RNA) is recommended for computing complement sequences\n</code></pre> \ud83d\udd53\u00a07.8\u00a0s\ud83d\udcc8\u00a028.1\u00a0MiB \ud83d\udd53\u00a06.0\u00a0s\ud83d\udcc8\u00a07.2\u00a0MiB"},{"location":"comparison/#concat","title":"concat","text":"Concatenate sequences, adding an <code>NNNNN</code> spacer inbetween   <pre><code>st concat -s 5 -c N file1.fastq file2.fastq &gt; output.fastq\n</code></pre> VSEARCH \ud83d\udd53\u00a020.5\u00a0s VSEARCH <pre><code>vsearch --fastq_join file1.fastq --reverse file2.fastq --join_padgap NNNNN --fastqout output.fastq\n</code></pre> \u00a0messages <pre><code>vsearch v2.28.1_linux_x86_64, 30.6GB RAM, 16 cores\nhttps://github.com/torognes/vsearch\nJoining reads 100%\n2610480 pairs joined\n</code></pre> \ud83d\udd53\u00a020.5\u00a0s\ud83d\udcc8\u00a04.2\u00a0MiB\u00a0\ud83c\udfc6 (1.74x) \ud83d\udd53\u00a09.9\u00a0s\u00a0\ud83c\udfc6 (2.1x)\ud83d\udcc8\u00a07.4\u00a0MiB"},{"location":"concat/","title":"concat","text":"<p>Concatenates sequences/alignments from different files</p> <p>The sequence IDs must be in the same order in all files; Fails if the IDs don't match.</p> <p><pre><code>Usage: st concat [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Concat' command options:\n  -n, --no-id-check      Don't check if the IDs of the records from the\n                         different files match\n  -s, --spacer &lt;SPACER&gt;  Add a spacer of &lt;N&gt; characters inbetween the\n                         concatenated sequences\n  -c, --s-char &lt;S_CHAR&gt;  Character to use as spacer for sequences [default: N]\n  -Q, --q-char &lt;Q_CHAR&gt;  Character to use as spacer for qualities. Defaults to a\n                         phred score of 41 (Illumina 1.8+/Phred+33 encoding,\n                         which is the default assumed encoding) [default: J]\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"concat/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"count/","title":"count","text":"<p>Count all records in the input (total or categorized by variables/functions)</p> <p>The overall record count is returned for all input files collectively. Optionally, grouping categories (text or numeric) can be specified using <code>-k/--key</code>. The tab-delimited output is sorted by the categories.</p> <p><pre><code>Usage: st count [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Count' command options:\n  -k, --key &lt;KEY&gt;\n          Count sequences for each unique value of the given category. Can be a\n          single variable/function such as 'filename', 'desc' or 'attr(name)',\n          or a composed key such as '{filename}_{meta(species)}'. The `-k/--key`\n          argument can be specified multiple times, in which case there will be\n          multiple category columns, one per key. Alternatively, a\n          comma-delimited list of keys can be provided\n  -l, --category-limit &lt;CATEGORY_LIMIT&gt;\n          Maximum number of categories to count before aborting with an error.\n          This limit is a safety measure to prevent memory exhaustion. A very\n          large number of categories could unintentionally occur with a\n          condinuous numeric key (e.g. `gc_percent`). These can be grouped into\n          regular intervals using `bin(&lt;variable&gt;, &lt;interval&gt;)` [default:\n          1000000]\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"count/#counting-the-overall-record-number","title":"Counting the overall record number","text":"<p>By default, the count command returns the overall number of records in all of the input (even if multiple files are provided):</p> <pre><code>st count *.fastq\n</code></pre> <pre><code>10648515\n</code></pre>"},{"location":"count/#categorized-counting","title":"Categorized counting","text":"<p>Print record counts per input file:</p> <pre><code>st count -k path input.fasta input2.fasta input3.fasta\n</code></pre> <pre><code>input.fasta   1224818\ninput2.fasta  573\ninput3.fasta  99186\n</code></pre> <p>If the record count should be listed for each file separately, use the <code>path</code> or <code>filename</code> variable:</p> <p><pre><code>st count -k path *.fasta\n</code></pre> <pre><code>file1.fasta    6470547\nfile2.fasta    24022\nfile3.fasta    1771678\n</code></pre></p> <p>To print the sequence length distribution:</p> <p><pre><code>st count -k seqlen input.fasta\n</code></pre> <pre><code>102 1\n105 2\n106 3\n(...)\n</code></pre></p>"},{"location":"count/#multiple-keys","title":"Multiple keys","text":"<p>It is possible to use multiple keys. Consider an example similar to the primer finding example, but in addition we also store the number of primer mismatches (edit distance) in the <code>diffs</code> header attribute. After trimming, we can visualize the mismatch distribution for each primer:</p> <p><pre><code>st find file:primers.fasta -a primer='{pattern_name}' -a end='{match_end}' -a diffs='{match_diffs}' sequences.fasta |\n    st trim -e '{attr(end)}:' &gt; trimmed.fasta\nst count -k 'attr(primer)' -k 'attr(diffs)' trimmed.fasta\n</code></pre> <pre><code>primer1 0   249640\nprimer1 1   23831\nprimer1 2   2940\nprimer1 3   123\nprimer1 4   36\nprimer1 5   2\nprimer2 0   448703\nprimer2 1   60373\nprimer2 2   8996\nprimer2 3   691\nprimer2 4   34\nprimer2 5   7\nprimer2 6   1\nundefined   undefined   5029\n</code></pre></p>"},{"location":"count/#expressions-as-keys","title":"Expressions as keys","text":"<p>Assuming that we need to trim both the forward and reverse primer from a FASTQ file, we might categorize by the sum of the forward and reverse mismatches using an expression.</p> <p><pre><code># first, search and trim\nst find file:f_primers.fasta sequences.fastq \\\n     -a f_primer='{pattern_name}' -a f_end='{match_end}' -a f_diffs='{match_diffs}' |\n  st find --fq file:r_primers.fasta \\\n     -a r_primer='{pattern_name}' -a r_start='{match_start}' -a r_diffs='{match_diffs}' |\n  st trim --fq -e '{attr(f_end)}:{attr(r_start)}' &gt; trimmed.fastq\n# then count\nst count -k 'attr(f_primer)' -k 'attr(r_primer)' -k 'attr(diffs)' \\\n  -k '{ num(attr(\"f_diffs\")) + num(attr(\"r_diffs\")) }' trimmed.fastq\n</code></pre> <pre><code>f_primer1   r_primer1   0   3457490\nf_primer1   r_primer1   1   491811\nf_primer1   r_primer1   2   6374\nf_primer1   r_primer1   3   420\nf_primer1   r_primer1   4   10\n(...)\n</code></pre></p> <p>A few important points</p> <p>\u26a0 JavaScript expressions always need to be enclosed in <code>{curly braces}</code>, while simple variables/functions only require this  in some cases.</p> <p>\u26a0 Attribute names need to be in double or single quotes: <code>attr(\"f_dist\")</code>.</p> <p>\u26a0 The <code>f_dist</code> and <code>r_dist</code> attributes are numeric, but seqtool doesn't know that (see below), and the JavaScript expression would simply concatenate them as strings instead of adding the numbers up. Therefore we require the <code>num</code> function for conversion to numeric.</p>"},{"location":"count/#numeric-keys","title":"Numeric keys","text":"<p>With numeric keys, it is possible to summarize over intervals using the  <code>bin(number, interval)</code> function. Example summarizing the GC content:</p> <p><pre><code>st count -k '{bin(gc_percent, 10)}' seqs.fasta\n</code></pre> <pre><code>(10, 15]    2\n(15, 20]    9\n(20, 25]    357\n(25, 30]    1397\n(30, 35]    3438\n(35, 40]    2080\n(40, 45]    1212\n(45, 50]    1424\n(50, 55]    81\n</code></pre></p> <p>The intervals <code>(start,end]</code> are open at the start and closed at the end, meaning that <code>start &lt;= value &lt; end</code>.</p>"},{"location":"count/#numbers-stored-as-text","title":"Numbers stored as text","text":"<p>In case of a header attribute <code>attr(name)</code> or a value from an associated list <code>meta(column)</code>, these are always interpreted as text by default, unless the <code>num(...)</code> function is used, which makes sure that the categories are correctly sorted:</p> <pre><code>st count -k 'num(attr(numeric_attr))' input.fasta\n</code></pre>"},{"location":"count/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"del/","title":"del","text":"<p>Delete header ID/description and/or attributes</p> <p><pre><code>Usage: st del [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Del' command options:\n  -d, --desc           Delete description fields\n      --attrs &lt;ATTRS&gt;  Delete attributes\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"expressions/","title":"Expressions","text":""},{"location":"expressions/#expressions","title":"Expressions","text":"<p>Seqtool can evaluate mathematical expressions, but also supports more complex programming code; thanks to the tiny integrated JavaScript engine (QuickJS). This allows for solving problems that would normally require writing a custom script (which would often run slower).</p> <p>Another important use case for expressions is the powerful filter command.</p> <p>A comprehensive JavaScript language overview can be found on this Mozilla site.</p>"},{"location":"expressions/#usage","title":"Usage","text":"<p>Expressions are always written in curly brackets: <code>{ expression }</code>. They can be used at any place where variables/functions are allowed.</p> <p>Exception: filtering expressions don't need braces</p>"},{"location":"expressions/#strings-numbers","title":"Strings + numbers","text":"<p>JavaScript has a special behavior when it comes to adding strings + numbers:</p> <p><code>\"a\" + 1</code> just concatenates the two, producing the string <code>\"a1\"</code>. Things become confusing if numbers are stored as strings: <code>\"1\" + 2</code> gives <code>\"12\"</code> instead of just <code>3</code>.</p> <p>In seqtool, many variables/functions are (respectively return) text/strings. Examples for numeric variables are <code>seqhash</code>, <code>seq_num</code> as well as all sequence statistics variables. The exact type can be found by typing <code>st &lt;command&gt; --help-vars</code>:</p> <p></p> <p>TODO: add type to var reference</p> <p>Functions for header attribute and metadata access are the most prone to this issue. The functions <code>attr(name)</code> and <code>meta(column)</code> always return text, since seqtool doesn't know or check whether the given text is a number or not.  Consequently, <code>attr(\"name\") + 1</code> will just concatenate <code>1</code> to the attribute value instead of adding the numbers.</p> <p>Solution: Convert to numeric with the <code>num</code> function: <code>num(attr(\"name\")) + 1</code>. Num works like <code>parseFloat()</code>, but stops with an error if the given string is not a number.</p>"},{"location":"expressions/#string-function-arguments","title":"String function arguments","text":"<p>A peculiarity of seqtool functions are unquoted string arguments. These are allowed in a non-expression context in order to prevent users from having to use both single and double quotes. Example:</p> <pre><code>st sort 'attr(a)' input.fasta\n</code></pre> <p>As soon as an expression is used, arguments need to be quoted, otherwise the <code>a</code> is interpreted as a variable:</p> <pre><code>st sort 'num(attr(\"a\")) + num(attr(\"b\"))' input.fasta\n</code></pre>"},{"location":"expressions/#initialization","title":"Initialization","text":"<p>(TODO: explain <code>--js-init</code>...)</p>"},{"location":"expressions/#regular-expressions","title":"Regular expressions","text":"<p>Using the regular expression /literal/ syntax is not possible, since seqtool has its own script parsing routine, which cannot handle such complex cases.  Use the <code>RegExp</code> class instead, e.g.: <code>desc.match(new RegExp(\"xy\\d+\"))</code>.</p>"},{"location":"filter/","title":"filter","text":"<p>Keep/exclude sequences based on different properties with a mathematical (JavaScript) expression</p> <p><pre><code>Usage: st filter [OPTIONS] &lt;EXPRESSION&gt; [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Filter' command options:\n  -d, --dropped &lt;FILE&gt;  Output file for sequences that were removed by\n                        filtering. The format is auto-recognized from the\n                        extension\n  &lt;EXPRESSION&gt;          Filter expression\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"filter/#examples","title":"Examples","text":"<p>Removing sequences shorter than 100 bp:</p> <pre><code>st filter \"seqlen &gt;= 100\" input.fasta &gt; filtered.fasta\n</code></pre> <p>Removing DNA sequences with more than 10% of ambiguous bases:</p> <pre><code>st filter \"charcount(ACGT) / seqlen &gt;= 0.9\" input.fasta &gt; filtered.fasta\n</code></pre> <p>Quick and easy way to select certain sequences:</p> <pre><code>st filter \"id == 'id1' \" input.fasta &gt; filtered.fasta\n\nst filter \"['id1', 'id2', 'id3'].contains(id)\" input.fasta &gt; filtered.fasta\n</code></pre> <p>Note: this may not be the most efficient way, consider a text file with an ID list</p>"},{"location":"filter/#quality-filtering","title":"Quality filtering","text":"<p>The <code>exp_err</code> statistics variable represents the total expected number of errors in a sequence, as provided by the quality scores. By default, the Sanger / Illumina 1.8+ format (with ASCII offset 33) is assumed. See here for more information.</p> <p>This example removes sequences with less than one expected error. The output is the same as for <code>fastq_filter</code> if  USEARCH or VSEARCH.</p> <pre><code>st filter 'exp_err &lt;= 1' input.fastq -o filtered.fasta\n</code></pre> <p>Normalization according to sequence length is easily possible with a math formula (corresponding to <code>-fastq_maxee_rate</code> in USEARCH).</p> <pre><code>st filter 'exp_err / seqlen &gt;= 0.002' input.fastq -o filtered.fasta\n</code></pre>"},{"location":"filter/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"find/","title":"find","text":"<p>Search for pattern(s) in sequences or sequene headers for record filtering, pattern replacement or passing hits to next command</p> <p>There are different search modes:</p> <ol> <li>Exact search</li> <li>Regular expressions (<code>-r/--regex</code>)</li> <li>DNA or protein patterns with ambiguous letters</li> <li>Approximate matching up to a given edit distance     (<code>-D/--max-diffs</code> or <code>-R/--max-diff-rate</code>)</li> </ol> <p>Search results can be used in three different ways:</p> <ol> <li>Keeping (<code>-f/--filter</code>) or excluding (<code>-e/--exclude</code>) matched    sequences</li> <li>Pattern replacement (<code>--rep</code>) with ambiguous/approximate    matching (for exact/regex replacement, use the 'replace'    command)</li> <li>Passing the search results to the output in sequence    headers (<code>-a/--attr</code>) or TSV/CSV fields (<code>--to-tsv/--to-csv</code>);    see <code>st find -V/--help-vars</code> for all possible variables/    functions</li> </ol> <p><pre><code>Usage: st find [OPTIONS] &lt;PATTERNS&gt; [INPUT]...\n\nArguments:\n  &lt;PATTERNS&gt;  Pattern string or 'file:&lt;patterns.fasta&gt;'\n\nOptions:\n  -h, --help  Print help\n\nWhere to search (default: sequence):\n  -i, --id    Search / replace in IDs instead of sequences\n  -d, --desc  Search / replace in descriptions\n\nSearch options:\n  -D, --max-diffs &lt;N&gt;\n          Return pattern matches up to a given maximum edit distance of N\n          differences (= substitutions, insertions or deletions). Residues that\n          go beyond the sequence (partial matches) are always counted as\n          differences. [default: pefect match]\n  -R, --max-diff-rate &lt;R&gt;\n          Return of matches up to a given maximum rate of differences, that is\n          the fraction of divergences (edit distance = substitutions, insertions\n          or deletions) divided by the pattern length. If searching a 20bp\n          pattern at a difference rate of 0.2, matches with up to 4 differences\n          (see also `-D/--max-diffs`) are returned. [default: pefect match]\n  -r, --regex\n          Interpret pattern(s) as regular expression(s). All *non-overlapping*\n          matches in are searched in headers or sequences. The regex engine\n          lacks some advanced syntax features such as look-around and\n          backreferences (see https://docs.rs/regex/#syntax). Capture groups can\n          be extracted by functions such as `match_group(number)`, or\n          `match_group(name)` if named: `(?&lt;name&gt;)` (see also `st find\n          --help-vars`)\n  -c, --case-insensitive\n          Ignore case in patterns and text. By default, pattern and text case\n          must match exactly; soft-masked text is thus not matched by an\n          uppercase pattern unless `-c` is specified\n      --in-order\n          Report hits in the order of their occurrence instead of sorting by\n          distance. Note that this option only has an effect with\n          `-D/--max-dist` &gt; 0, otherwise matches are always reported in the\n          order of their occurrence\n  -t, --threads &lt;N&gt;\n          Number of threads to use for searching [default: 1]\n      --no-ambig\n          Don't recognize DNA/RNA ambiguities (IUPAC) in patterns\n      --algo &lt;NAME&gt;\n          Override decision of algorithm for testing (regex/exact/myers/auto)\n          [default: auto]\n      --hit-scoring &lt;Ma,Mi,Gap&gt;\n          Scoring to use for prioritizing among multiple matches with the same\n          starting position and an equally small edit distance. Should be\n          provided in the form: `match,mismatch,gap` The default gap penalty of\n          -2 leads to more concise alignments. A high gap penalty does *not*\n          enforce ungapped alignments. Only perfect matches (`-D/--max-diffs 0`)\n          are ungapped [default: 1,-1,-2]\n\nSearch range:\n      --rng &lt;RANGE&gt;\n          Search within the given range ('start:end', 'start:' or ':end'). Using\n          variables is not possible\n      --anchor-start &lt;TOLERANCE&gt;\n          Consider only matches anchored to the start of the sequence (or the\n          search range `--rng`), whereby a the start of the match may be shifted\n          towards the right by a maximum of &lt;TOLERANCE&gt; letters. Additional\n          approximate matches further towards the end are not considered (even\n          if better)\n      --anchor-end &lt;TOLERANCE&gt;\n          Consider only matches anchored to the end of the sequence (or the\n          search range `--rng`), whereby a the end of the match may be shifted\n          towards the left by a maximum of &lt;TOLERANCE&gt; letters. Additional\n          approximate matches further towards the start are not considered (even\n          if better)\n\nSearch command actions:\n  -f, --filter          Keep only matching sequences\n  -e, --exclude         Exclude sequences that matched\n      --dropped &lt;FILE&gt;  Output file for sequences that were removed by\n                        filtering. The format is auto-recognized from the\n                        extension\n      --rep &lt;BY&gt;        Replace by a string, which may also contain\n                        {variables/functions}\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"find/#searching-in-headers","title":"Searching in headers","text":"<p>Specify <code>-i/--id</code> to search in sequence IDs (everything before the first space) or <code>-d/--desc</code> to search in the description part (everything after the space).</p> <p>Example: selectively return sequences that have <code>label</code> in their description (filtering with the <code>-f/--filter</code> flag):</p> <pre><code>st find -df 'label' gb_seqs.fasta\n</code></pre> <p>Note: use <code>--dropped &lt;not_matched_out&gt;</code> to write unmatched sequences to  another file.</p> <p>To match a certain pattern, use a regular expression (<code>-r/--regex</code>). The following example extracts Genbank accessions from sequence headers that follow the old-style Genbank format:</p> <pre><code>st find -ir \"gi\\|\\d+\\|[a-z]+\\|(?&lt;acc&gt;.+?)\\|.*\" gb_seqs.fasta -a 'acc={match_group(acc)}'\n</code></pre> <pre><code>&gt;gi|1031916024|gb|KU317675.1| acc=KU317675.1\nSEQUENCE\n(...)\n</code></pre> <p>You can use online tools such as https://regex101.com to build and debug your regular expression</p> <p>Note: You could also replace the whole header with the accession using the replace command. This might be faster, but the original header will not be retained.</p>"},{"location":"find/#searching-in-sequences","title":"Searching in sequences","text":"<p>Without the <code>-i</code> or <code>-d</code> flag, the default mode is to search in the sequence. The pattern type is automatically recognized and usually reported to avoid problems:</p> <pre><code>st find -f AATGRAAT seqs.fasta &gt; filtered.fasta\n</code></pre> <pre><code>Note: the sequence type of the pattern was determined as 'dna' (with ambiguous letters). If incorrect, please provide the correct type with `--seqtype`. Use `-q/--quiet` to suppress this message.\n</code></pre> <p><code>R</code> stands for <code>A</code> or <code>G</code>. Seqtool recognizes the IUPAC ambiguity codes for DNA/RNA and proteins (with the exception of U = Selenocysteine).</p> <p>\u26a0 Matching is asymmetric: <code>R</code> in a search pattern matches [<code>A</code>, <code>G</code>, <code>R</code>] in sequences, but <code>R</code> in a sequence will only match ambiguities sharing the same set of bases (<code>R</code>, <code>V</code>, <code>D</code>, <code>N</code>) in the pattern. This should prevent false positive matches in sequences with many ambiguous characters.</p>"},{"location":"find/#approximate-matching","title":"Approximate matching","text":"<p>Seqtool can search for patterns such as adapter and primer sequences in an error-tolerant way, up to a given edit distance (<code>-D/--diffs</code> argument). Alternatively, <code>-R/--diff-rate</code> specifies a distance threshold relative to the length of the pattern (in other words, an \"error rate\").</p> <p>In this example, the edit distance and range of the best match are stored into header attributes. If no hit is found, the attributes are set to <code>undefined</code>.</p> <pre><code>st find -D 2 AATGRAAT seqs.fasta -a d='{match_diffs}' -a rng='{match_range}'\n</code></pre> <pre><code>&gt;seq1 d=1 rng=3:11\nGGAACGAAATATCAGCGATCC\n&gt;seq2 d=undefined rng=undefined\nTTATCGAATATGAGCGATCG\n(...)\n</code></pre> <p>The second best hit (if any) can be returned with <code>{match_diffs(2)}</code> or <code>{match_range(2)}</code>, etc.</p> <p>Note: Approximative matching is done using Myers bit-parallel algorithm, which is very fast with short patterns and reasonably short sequences. It may not be the fastest solution if searching in large genomes.</p> <p>Recognizing adapter or primers should be very fast. Further speedups can be achieved by multithreading (<code>-t</code>) and restricting the search range (<code>--rng</code>).</p> <p>Note 2: To report all hits below the given distance threshold  in order of occurrence instead of decreasing distance, specify <code>--in-order</code> (this may be faster)</p>"},{"location":"find/#multiple-patterns","title":"Multiple patterns","text":"<p>The find command supports searching for several patterns at once. They have to be supplied in a separate FASTA file (<code>file:path</code>). The best matching pattern with the smallest edit distance is always reported first.</p> <p>The following example de-multiplexes sequences amplified with different forward primers and then uses trim to remove the primers, and finally distributes the sequences into different files named by the forward primer (split).</p>   primers.fasta   <pre><code>&gt;prA\nPRIMER\n&gt;prB\nPRIMER\n</code></pre> <pre><code>st find file:primers.fasta -a primer='{pattern_name}' -a end='{match_end}' sequences.fasta |\n    st trim -e '{attr(end)}:' |\n    st split -o '{attr(primer)}'\n</code></pre> prA.fasta  prB.fasta undefined.fasta <pre><code>&gt;id1 primer=prA end=22\nSEQUENCE\n&gt;id4 primer=prA end=21\nSEQUENCE\n(...)\n</code></pre> <pre><code>&gt;id2 primer=prB end=20\nSEQUENCE\n&gt;id3 primer=prB end=22\nSEQUENCE\n(...)\n</code></pre> <pre><code>&gt;id5 primer=undefined end=undefined\nUNTRIMMEDSEQUENCE\n(...)\n</code></pre>  &gt; Note: no primer, sequence not trimmed since <code>end=undefined</code> (see ranges)."},{"location":"find/#selecting-other-hits","title":"Selecting other hits","text":"<p>The find command is very versatile thanks to the large number of variables/functions that provide information about the search results (see variable reference).</p> <p>For instance, the best hit from the second best matching pattern can be selected using <code>{match_range(1, 2)}</code>.</p> <p>It is also possible to return a comma-delimited list of matches, e.g.: <code>{match_range(all)}</code>. See the mask command for an example on how this could be useful.</p>"},{"location":"find/#replacing-matches","title":"Replacing matches","text":"<p>Hits can be replaced by other text (<code>--repl</code>). Variables are allowed as well (in contrast to the replace command). Backreferences to regex groups (e.g. <code>$1</code>) are not supported like the replace command does. Instead, they can be accessed using variables (<code>match_group()</code>, etc.)</p>"},{"location":"find/#more","title":"More","text":"<p>This page lists more examples with execution times and comparisons with other tools.</p>"},{"location":"find/#variablesfunctions-provided-by-the-find-command","title":"Variables/functions provided by the 'find' command","text":"<p>see also <code>st find -V</code> or <code>st find --help-vars</code></p> <p>The find command provides many variables/functions to obtain information about the pattern matches. These are either written to header attributes (<code>-a/--attr</code>) or CSV/TSV fields (e.g. <code>--to-tsv ...</code>). See also examples section below.</p> matchmatch(hit)match(hit, pattern) The text matched by the pattern. With approximate matching (<code>-D/--diffs</code> or <code>-R/--max-diff-rate</code> &gt; 0), this is the best match or the leftmost occurrence (with <code>--in-order</code>) of the best-matching pattern (in case of multiple). With exact or regex matching, this is the leftmost hit of the first matching pattern. Options: <code>match(1)</code>, <code>match(2)</code>, etc.: the matched text of hit no. 1, 2, etc. <code>match(all)</code> or <code>match('all')</code>: comma-delimited list of all hits, from best to worst (default for approximate matching) or left to right (<code>--in-order</code> or exact matching). <code>match(-1)</code>: the worst or rightmost match (-1 = last hit, -2 = second last, etc.). <code>match(\\&lt;hit\\&gt;, 2)</code>, <code>match(\\&lt;hit\\&gt;, 3)</code>, etc. returns the 2nd, 3rd, etc. best matching pattern in case multiple matching patterns (default: hit=1, pattern=1).\"return type: text aligned_matchaligned_match(hit)aligned_match(hit, rank) Text match aligned with the pattern, including gaps if needed; for details, see <code>match</code>return type: text match_startmatch_start(hit)match_start(hit, pattern) Start coordinate of the first/best match. Other hits/patterns are selected with <code>match_start(hit, [pattern])</code>, for details see <code>match</code>return type: number match_endmatch_end(hit)match_end(hit, pattern) Start of the first/best match relative to sequence end (negative coordinate). Other hits/patterns are selected with <code>match_neg_start(hit, [pattern])</code>, for details see <code>match</code>.return type: number match_neg_startmatch_neg_start(hit)match_neg_start(hit, pattern) End of the first/best match relative to sequence end (negative coordinate). Other hits/patterns are selected with <code>match_neg_end(hit, [pattern])</code>, for details see <code>match</code>.return type: number match_neg_endmatch_neg_end(hit)match_neg_end(hit, pattern) End coordinate of the first/best match. Other hits/patterns are selected with <code>match_end(hit, [pattern])</code>, for details see <code>match</code>return type: number match_lenmatch_len(hit)match_len(hit, rank) Length of the matchreturn type: number match_rangematch_range(hit)match_range(hit, pattern)match_range(hit, pattern, delim) Range (start:end) of the first/best match. Other hits/patterns are selected with <code>match_range(hit, [pattern])</code>, for details see <code>match</code>. The 3rd argument allows changing the range delimiter, e.g. to '-'.return type: text match_neg_rangematch_neg_range(hit)match_neg_range(hit, pattern)match_neg_range(hit, pattern, delim) Like <code>match_range</code>, but ranges have negative coordinates relative to the end.return type: text match_group(group)match_group(group, hit)match_group(group, hit, pattern) Text matched by regex match group of given number (0 = entire match) or name in case of a named group: <code>(?\\&lt;name\\&gt;...)</code>. The hit number (sorted by edit distance or occurrence) and the pattern number can be specified as well (see <code>match</code> for details).return type: text match_grp_start(group)match_grp_start(group, hit)match_grp_start(group, hit, pattern) Start coordinate of the regex match group 'group' within the first/best match. See 'match_group' for options and details.return type: number match_grp_end(group)match_grp_end(group, hit)match_grp_end(group, hit, pattern) End coordinate of the regex match group 'group' within the first/best match. See 'match_group' for options and details.return type: number match_grp_neg_start(group)match_grp_neg_start(group, hit)match_grp_neg_start(group, hit, pattern) Start coordinate of regex match group 'group' relative to the sequence end (negative number). See 'match_group' for options and details.return type: number match_grp_neg_end(group)match_grp_neg_end(group, hit)match_grp_neg_end(group, hit, pattern) Start coordinate of regex match group 'group' relative to the sequence end (negative number). See 'match_group' for options and details.return type: number match_grp_range(group)match_grp_range(group, hit)match_grp_range(group, hit, pattern)match_grp_range(group, hit, pattern, delim) Range (start-end) of regex match group 'group' relative to the sequence end. See 'match_group' for options and details. The 4th argument allows changing the range delimiter, e.g. to '-'.return type: number match_diffsmatch_diffs(hit)match_diffs(hit, pattern) Number of mismatches/insertions/deletions of the search pattern compared to the sequence (corresponds to edit distance). Either just <code>match_diffs</code> for the best match, or <code>match_diffs(h, [p])</code> to get the edit distance of the h-th best hit of the p-th pattern. `match_diffs('all', [p]) will return a comma delimited list of distances for all hits of a pattern.return type: number match_diff_ratematch_diff_rate(hit)match_diff_rate(hit, pattern) Number of insertions in the sequence compared to the search pattern. Proportion of differences between the search pattern and the matched sequence, relative to the pattern length. See <code>match_diffs</code> for details on hit/pattern arguments.return type: number match_insmatch_ins(hit)match_ins(hit, pattern) Number of insertions in the matched sequence compared to the search pattern.return type: number match_delmatch_del(hit)match_del(hit, pattern) Number of deletions in the matched text sequence to the search pattern.return type: number match_substmatch_subst(hit)match_subst(hit, pattern) Number of substitutions (non-matching letters) in the matched sequence compared to the patternreturn type: number pattern_namepattern_name(rank) Name of the matching pattern (patterns supplied with <code>file:patterns.fasta</code>). In case a single pattern was specified in the commandline, this will just be \\&lt;pattern&gt;. <code>pattern_name(rank)</code> selects the n-th matching pattern, sorted by edit distance and/or pattern number (depending on <code>-D/-R</code> and <code>--in-order</code>).return type: text patternpattern(rank) The best-matching pattern sequence, or the n-th matching pattern if <code>rank</code> is given, sorted by edit distance or by occurrence (depending on <code>-D/-R</code> and <code>--in-order</code>).return type: text aligned_patternaligned_pattern(hit)aligned_pattern(hit, rank) The aligned pattern, including gaps if needed. Regex patterns are returned as-is.return type: text pattern_lenpattern_len(rank) Length of the matching pattern (see also <code>pattern</code>). For regex patterns, the length of the complete regular expression is returned.return type: number"},{"location":"find/#examples","title":"Examples","text":"<p>Find a primer sequence with up to 2 mismatches (<code>-d/--dist</code>) and write the match range and the mismatches ('dist') to the header as attributes. The result will be 'undefined' (=undefined in JavaScript) if there are &gt; 2 mismatches: <pre><code>st find -d 2 CTTGGTCATTTAGAGGAAGTAA -a rng={match_range} -a dist={match_diffs} reads.fasta\n</code></pre> <pre><code>&gt;id1 rng=2:21 dist=1\nSEQUENCE\n&gt;id2 rng=1:20 dist=0\nSEQUENCE\n&gt;id3 rng=undefined dist=undefined\nSEQUENCE\n(...)\n</code></pre> Find a primer sequence and if found, remove it using the 'trim' command, while non-matching sequences are written to 'no_primer.fasta': <pre><code>st find -f -d 2 CTTGGTCATTTAGAGGAAGTAA --dropped no_primer.fasta -a end={match_end} reads.fasta |\n   st trim -e '{attr(match_end)}:' &gt; primer_trimmed.fasta\n</code></pre> Search for several primers with up to 2 mismatches and write the name and mismatches of the best-matching primer to the header: <pre><code>st find -d 2 file:primers.fasta -a primer={pattern_name} -a dist={match_diffs} reads.fasta\n</code></pre> <pre><code>&gt;id1 primer=primer_1 dist=1\nSEQUENCE\n&gt;id1 primer=primer_2 dist=0\nSEQUENCE\n&gt;id1 primer=undefined dist=undefined\nSEQUENCE\n(...)\n</code></pre></p>"},{"location":"formats/","title":"Sequence formats and compression","text":"<p>All commands accept different formats and compressed input, and writing to a different sequence and compression format is also possible. The input and output formats are automatically inferred based on the file extensions.</p> <p>Note: Currently, there is no auto-recognition of the formats</p> <p>The following pass command reads a GZIP compressed FASTQ file and converts it to uncompressed FASTA.</p> <pre><code>st pass input.fastq.gz -o output.fasta\n# or the equivalent shorthand:\nst . input.fastq.gz -o output.fasta\n</code></pre> <p>If receiving from STDIN or writing to STDOUT, the format has to be specified unless it is FASTA (which is the default):</p> <pre><code>wget -O - https://url/to/remote/seqs.fastq.gz | \n  st . --fmt fastq.gz --to fasta &gt; output.fasta\n</code></pre> <p>The output format is always assumed to be the same as the input format if not specified otherwise by using <code>--to &lt;format&gt;</code> or <code>-o &lt;path&gt;.&lt;extension&gt;</code>.</p> <p>There also exist shorthand notations such as <code>--to-fa</code> (shortcut in table below).</p>"},{"location":"formats/#recognized-formats","title":"Recognized formats","text":"<p>The following extensions and format strings are auto-recognized:</p> sequence format recognized extensions format string shortcut (in) ..out FASTA <code>.fasta</code>,<code>.fa</code>,<code>.fna</code>,<code>.fsa</code> <code>fasta</code>,<code>fa</code> <code>--fa</code> <code>--to-fa</code> FASTQ <code>.fastq</code>,<code>.fq</code> <code>fastq</code>,<code>fq</code>,<code>fq\u2014illumina</code>,<code>fq\u2014solexa</code> <code>--fq</code> <code>--to\u2014fq</code> CSV (<code>,</code> delimited) <code>.csv</code> <code>csv</code> <code>--csv FIELDS</code> <code>--to\u2014csv FIELDS</code> TSV (<code>tab</code> delimited) <code>.tsv</code>,<code>.tsv</code> <code>tsv</code> <code>--tsv FIELDS</code> <code>--to\u2014tsv FIELDS</code> <p>Note: Multiline FASTA is parsed and written (<code>--wrap</code>), but only single-line FASTQ is parsed and written.</p> <p>Besides FASTQ, quality scores can also be parsed from / written to 454 (Roche) style <code>QUAL</code> files using <code>--qual &lt;file&gt;</code> and <code>--to-qual &lt;file&gt;</code>.</p>"},{"location":"formats/#compression-formats","title":"Compression formats","text":"<p>No shortcuts are available for compression formats, therefore always use the long form: <code>--fmt &lt;input_format&gt;</code> / <code>--to &lt;output_format&gt;</code></p> format recognized extensions format string (FASTA) GZIP <code>.gzip</code>,<code>.gz</code> <code>fasta.gz</code> BZIP2 <code>.bzip2</code>,<code>.bz2</code> <code>fasta.bz2</code> LZ4 <code>.lz4</code> <code>fasta.lz4</code> ZSTD <code>.zst</code> <code>fasta.zst</code>"},{"location":"formats/#delimited-text-csv-tsv","title":"Delimited text (CSV, TSV, ...)","text":"<p>Comma / tab / ... delimited input and output can be configured providing the <code>--fields</code> / <code>--outfields</code> argument, or directly using <code>--csv</code>/<code>--to-csv</code> or <code>--tsv</code>/<code>--to-tsv</code>. The delimiter is configured with <code>--delim &lt;delim&gt;</code></p> <pre><code>st . --outfields id,seq -o output.tsv input.fasta\n</code></pre> <p>equivalent shortcut:</p> <pre><code>st . --to-tsv id,seq &gt; output.tsv\n</code></pre> <p>Variables/functions can also be included:</p> <pre><code>st . --to-tsv \"id,seq,length: {s:seqlen}\" input.fasta\n</code></pre> <pre><code>id1 ATGC(...)   length: 231\nid2 TTGC(...)   length: 250\n</code></pre>"},{"location":"formats/#setting-default-format-via-environment-variable","title":"Setting default format via environment variable","text":"<p>The <code>ST_FORMAT</code> environment variable can be used to set a default format other than FASTA. This is especially useful if connecting many commands via pipe, saving the need to specify <code>--fq</code> / <code>--tsv &lt;fields&gt;</code> / ... repeatedly. Example:</p> <pre><code>export ST_FORMAT=fastq\n\nst trim :10 input.fastq | st revcomp &gt; trimmed_revcomp.fastq\n</code></pre> <p>For delimited files (CSV or TSV), the input fields can be configured additionally after a colon (<code>:</code>):</p> <pre><code>export ST_FORMAT=tsv:id,seq\n\n## Input file:\n# id1 ACGT...\n# id2 ACGT...\n# ...\n\nst trim ':4' input.txt | st revcomp &gt; trimmed_revcomp.txt\n\n## Output:\n# id1 ACGT...\n# id2 ACGT...\n#...\n</code></pre>"},{"location":"formats/#quality-scores","title":"Quality scores","text":"<p>Quality scores can be read from several sources. FASTQ files are assumed to be in the Sanger/Illumina 1.8+ format (ASCII offset of 33). Older formats (Illumina 1.3+ and Solexa) with an offset of 64 can be read and written using <code>--fmt/--to fq-illumina</code> or <code>fq-solexa</code>. Automatic unambiguous recognition of the formats is not possible, therefore the formats have to be explicitly specified. Invalid characters generate an error during conversion.</p> <p>Note: If no conversion is done (e.g. both input and output in Sanger/Illumina 1.8+ format), scores are not automatically checked for errors.</p> <p>Quality scores can be visualized using the view command.</p> <p>The following example converts a legacy Illumina 1.3+ file to the Sanger/Illumina 1.8+ format:</p> <pre><code>st . --fmt fq-illumina --to.fastq illumina_1_3.fastq &gt; sanger.fastq\n</code></pre> <p>The <code>exp_err</code> variable uses the quality scores to calculate the total number of expected sequencing errors (see filter command). In order to correctly calculate the value of <code>exp_err</code> it is vital that the format is correctly specified.</p>"},{"location":"head/","title":"head","text":"<p>Return the first N sequences</p> <p><pre><code>Usage: st head [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Head' command options:\n  -n, --num-seqs &lt;N&gt;  Number of sequences to return [default: 10]\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"interleave/","title":"interleave","text":"<p>Interleave records of all files in the input</p> <p>The records are returned in the same order as in the input files.</p> <p><pre><code>Usage: st interleave [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Interleave' command options:\n  -n, --no-id-check  Don't check if the IDs of the files match\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"lower/","title":"lower","text":"<p>Convert sequences to lowercase</p> <p><pre><code>Usage: st lower [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"mask/","title":"mask","text":"<p>Soft or hard mask sequence ranges</p> <p>Masks the sequence within a given range or comma delimited list of ranges by converting to lowercase (soft mask) or replacing with a character (hard masking). Reverting soft masking is also possible.</p> <p><pre><code>Usage: st mask [OPTIONS] &lt;RANGES&gt; [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Mask' command options:\n      --hard &lt;CHAR&gt;  Do hard masking instead of soft masking, replacing\n                     everything in the range(s) with the given character\n      --unmask       Unmask (convert to uppercase instead of lowercase)\n  -e, --exclusive    Exclusive range: excludes start and end positions from the\n                     masked sequence. In the case of unbounded ranges (`start:`\n                     or `:end`), the range still extends to the complete end or\n                     the start of the sequence\n  -0, --zero-based   Interpret range as 0-based, with the end not included\n  &lt;RANGES&gt;           Range in the form 'start:end' or 'start:' or ':end', The\n                     range start/end may be defined by varialbes/functions, or\n                     the varialbe/function may contain a whole range\n</code></pre> See this page for the options common to all commands.</p> <p>A comma delimited list of ranges can be supplied, which may contain variables, or the whole range may be a variable.</p> <p>Masking ranges always include the start and end coordinates unless <code>-0</code> is specified. Coordinates can be negative to indicate an offset from the end. See explanation of ranges for more details.</p>"},{"location":"mask/#example","title":"Example","text":"<p>In this example, we search all occurrences of a pattern using a regular expression with the find command and store them as comma-delimited list using match_range(all):</p> <pre><code>st find -r -a rng='{match_range(all)}' '[AG]GA' input.fasta \\\n  | st mask 'attr(rng)'\n</code></pre> <p>Possible output:</p> <pre><code>&gt;seq1 rng=6:8,14:16\nAGTTAagaCTTAAggaT\n(...)\n</code></pre>"},{"location":"meta/","title":"Metadata from delimited files","text":"<p>In all seqtool commands, it is possible to integrate external metadata from delimited text files created manually or using another program.</p> <p>Files are specified using the <code>-m/--meta</code> option and accessed using the functions <code>meta(column)</code>,  <code>opt_meta(column)</code> (with missing data) or <code>has_meta(column)</code> (to check if the metadata is present). Column is either a number or the header name of the given column.</p> <p>See also variable reference and detailed description of command-line options</p> <p>By default, files are assumed to be tab-delimited, and the first column should contain the ID. However, this can be changed with <code>--meta-delim</code> and <code>--id-col</code>.</p>"},{"location":"meta/#examples","title":"Examples","text":"<p>Consider this list containing taxonomic information about sequences (genus.tsv):</p> <pre><code>id  genus\nseq1  Actinomyces\nseq2  Amycolatopsis\n(...)\n</code></pre> <p>The genus name can be added to the FASTA header using this command:</p> <pre><code>st set --meta genus.tsv --desc '{meta(genus)}' input.fasta &gt; with_genus.fasta\n# short:\nst set -m genus.tsv -d '{meta(genus)}' input.fasta &gt; with_genus.fasta\n</code></pre> <pre><code>&gt;seq1 Actinomyces\nSEQUENCE\n&gt;seq2 Amycolatopsis\nSEQUENCE\n(...)\n</code></pre> <p>If any of the sequence IDs is not found in the metadata, there will be an error. If missing data is expected, use <code>opt_meta</code> instead. Missing entries are <code>undefined</code>:</p> <pre><code>st set -m genus.tsv --desc '{opt_meta(genus)}' input.fasta &gt; with_genus.fasta\n</code></pre> <pre><code>&gt;seq1 Actinomyces\nSEQUENCE\n&gt;seq2 Amycolatopsis\nSEQUENCE\n&gt;seq3 undefined\nSEQUENCE\n(...)\n</code></pre>"},{"location":"meta/#filtering-by-id","title":"Filtering by ID","text":"<p>Sometimes it is necessary to select all sequence records present in a list of sequence IDs. This can easily be achieved using this command:</p> <pre><code>st filter -m id_list.txt 'has_meta()' seqs.fasta &gt; in_list.fasta\n</code></pre>"},{"location":"meta/#multiple-metadata-sources","title":"Multiple metadata sources","text":"<p>Several sources can be simultaneously used in the same command with <code>-m file1 -m file2 -m file3...</code>:</p> <pre><code>st filter -m source1.txt -m source2.txt 'meta(\"column\", 1) == \"value\" &amp;&amp; has_meta(2)' seqs.fasta &gt; in_list.fasta\n</code></pre> <p>Sources are referenced using <code>meta(column, file_number)</code> or <code>has_meta(file_number)</code>; see also variable reference</p>"},{"location":"opts/","title":"Commandline options","text":""},{"location":"opts/#options-recognized-by-all-commands","title":"Options recognized by all commands","text":"<pre><code>General options (common to all commands):\n  -v, --verbose    Print more detailed information about the progress and\n                   results of certain commands\n  -q, --quiet      Suppress all messages except errors and important warnings\n      --help-vars  List and explain all variables/functions available\n\nInput (common to all commands):\n      --fmt &lt;FMT&gt;        Input format, only needed if it cannot be guessed from\n                         the extension (e.g. if reading from STDIN). 'fasta' is\n                         assumed as default (can be configured with ST_FORMAT).\n                         Possible choices: fasta (default), fastq\n                         (fastq-illumina, fastq-solexa), csv or tsv.\n                         Compression: &lt;format&gt;.&lt;compression&gt; (.gz, .bz2 or .lz4)\n                         [env: ST_FORMAT=]\n      --fa               FASTA input. Short for '--fmt fasta'\n      --fq               FASTQ input. Short for '--fmt fastq'\n      --fq-illumina      FASTQ input in legacy Illumina 1.3-1.7 format (alias to\n                         --fmt fastq-illumina)\n      --fields &lt;FIELDS&gt;  Delimited text fields: 'id,seq,desc' (in order) or\n                         'id:2,desc:6,seq:9' (col. num.) or\n                         'id:ID,seq:Sequence,desc:Comment' (names in header)\n                         [default: 'id,seq,desc']\n      --delim &lt;CHAR&gt;     TSV/CSV delimiter. Defaults: '\\t' for tsv/txt and ','\n                         for csv\n      --header           Specify if CSV file has a header. Auto-enabled if a\n                         'field:column name' mapping is provided with --fields,\n                         --csv or --tsv\n      --csv &lt;FIELDS&gt;     CSV input. Short for '--fmt csv --fields &lt;fields&gt;'\n      --tsv &lt;FIELDS&gt;     TSV input. Short for '--fmt tsv --fields &lt;fields&gt;'\n      --qual &lt;FILE&gt;      Path to QUAL file with quality scores (Roche 454 style)\n      --seqtype &lt;TYPE&gt;   Sequence type; relevant for the `find` and `revcomp`\n                         commands, as well as the variables/functions\n                         `seq_revcomp`, `seqhash_rev` and `seqhash_both`\n                         (default: auto-detected based on the first sequence)\n                         [possible values: dna, rna, protein, other]\n  [INPUT]...             Input file(s), multiple possible (use '-' for STDIN)\n                         [default: -]\n\nOutput (common to all commands):\n  -o, --output &lt;FILE&gt;       Write output to &lt;file&gt; instead of STDOUT [Default:\n                            STDOUT (-)]\n      --append              Append sequences to the end if the output file(s)\n                            already exist instead of replacing the content. In\n                            case writing to standard output (which is the\n                            default if `-o/--output` is not specified), this\n                            option has no effect\n      --to &lt;FORMAT&gt;         Output format and compression. See --fmt. Only\n                            needed if not guessed from the extension (default:\n                            input format)\n      --wrap &lt;WIDTH&gt;        Wrap FASTA sequences to maximum &lt;width&gt; characters\n      --out-delim &lt;DELIM&gt;   TSV/CSV delimiter. Defaults: '\\t' for tsv/txt and\n                            ',' for csv\n      --outfields &lt;FIELDS&gt;  Comma delimited list of CSV/TSV fields, which can be\n                            variables/functions or contain\n                            {variables}/{expressions}. [default: input fields or\n                            'id,desc,seq']\n      --to-fa               FASTA output. Short for: '--to fasta'\n      --to-fq               FASTQ output. Short for: '--to fastq'\n      --to-csv &lt;FIELDS&gt;     CSV output with comma delimited list of fields,\n                            which can be variables/functions or contain\n                            variables/expressions. Short for '--to csv\n                            --outfields &lt;f&gt;'\n      --to-tsv &lt;FIELDS&gt;     TSV output with comma delimited list of fields,\n                            which can be variables/functions or contain\n                            variables/expressions. Short for '--to tsv\n                            --outfields &lt;f&gt;'\n      --compr-level &lt;L&gt;     Level for compressed output. 1-9 for GZIP/BZIP2\n                            (default=6) and 1-16 for LZ4 (default=0). 1-22 for\n                            Zstandard (default=3 or 0)\n      --qual-out &lt;FILE&gt;     Path to QUAL output file with quality scores\n\nFASTA/Q header attributes (all commands):\n  -a, --attr &lt;KEY=VALUE&gt;   Add an attribute in the form name=value to\n                           FASTA/FASTQ headers or replace their value if the\n                           given name already exists (multiple -a key=value\n                           arguments possible). The default output format is:\n                           '&gt;id some description key1=value1 key2=value2'. Use\n                           --attr-format to change\n  -A, --attr-append &lt;K=V&gt;  Append one or multiple attributes in the form\n                           name=value to FASTA/FASTQ headers. Compared to\n                           `-a/--attr`, existing attributes in headers are NOT\n                           replaced. This will result in a duplicate entry if\n                           the given attribute name already exists\n      --attr-fmt &lt;FMT&gt;     Expected format of sequence header attributes, which\n                           is also used for writing new attributes to headers\n                           (using -a/--attr). The words 'key' and 'value' must\n                           always be present, and 'value' must follow after\n                           'key'. Example: ';key=value'. If the delimiter before\n                           the key is not a space attributes are appended to the\n                           ID (part before the first space) instead of the end\n                           of the header [env: ST_ATTR_FORMAT=] [default: \"\n                           key=value\"]\n\nAssociated metadata (all commands):\n  -m, --meta &lt;FILE&gt;        Delimited text file path (or '-' for STDIN)\n                           containing associated metadata, accessed using the\n                           `meta(field)` function, or `meta(field, file-num)` in\n                           case of multiple metadata files (supplied like this:\n                           -m file1 -m file2 ...)\n      --meta-delim &lt;CHAR&gt;  Metadata column delimiter. Inferred from the file\n                           extension if possible: '.csv' is interpreted as\n                           comma(,)-delimited, '.tsv'/'.txt' or other (unknown)\n                           extensions are assumed to be tab-delimited [default:\n                           \"\\t\"]\n      --meta-header        Specify if the first row of the metadata file(s)\n                           contains column names. Automatically enabled if a\n                           non-numeric field names are used, e.g.\n                           'meta(fieldname)'\n      --meta-idcol &lt;NUM&gt;   Column number containing the sequence record IDs\n                           [default: 1]\n      --dup-ids            Specify if the sequence input is expected to contain\n                           duplicate IDs. Without this flag, there may be an\n                           error (`meta` and `has_meta` functions), whereas\n                           `opt_meta` may wrongly return missing values\n\nExpressions/scripts (all commands):\n      --js-init &lt;CODE&gt;  Javascript code to execute during initialization (e.g.\n                        for defining global variables used later during\n                        parsing). Either a plain string or\n                        'file:path/to/file.js'\n\nAdvanced (all commands):\n      --max-read-mem &lt;SIZE&gt;  Buffer size limit for the internal FASTA/FASTQ\n                             reader. Larger sequence records will cause an\n                             error. Note, that some commands such as 'sort',\n                             'unique' and 'sample' still use more memory and\n                             have their own additional memory limit setting.\n                             Either a plain number (bytes) a number with unit\n                             (K, M, G, T) based on powers of 2 [default: 1G]\n  -T, --read-thread          Read from a different thread. Enabled with\n                             compressed input\n  -W, --write-thread         Write in a different thread. Enabled with\n                             compressed output\n</code></pre>"},{"location":"pass/","title":"pass","text":"<p>Directly pass input to output without any processing, useful for converting and attribute setting</p> <p><pre><code>Usage: st pass [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n</code></pre> See this page for the options common to all commands.</p> <p>The <code>pass</code> command does nothing to the sequence records, it just passes them directly to the output. Still, this is an useful command for the following:</p> <ul> <li>Format conversion</li> <li>Editing header attributes</li> </ul>"},{"location":"pass/#examples","title":"Examples","text":""},{"location":"pass/#convert-gzip-compressed-fastq-to-fasta","title":"Convert GZIP-compressed FASTQ to FASTA:","text":"<pre><code>st pass input.fastq.gz -o output.fasta\n</code></pre> <p>equivalent, shorter notation:</p> <pre><code>st . input.fastq.gz -o output.fasta\n</code></pre>"},{"location":"pass/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"ranges/","title":"Explanation of ranges","text":"<p>Ranges in seqtool are used or produced by commands like trim, find, mask, and slice.</p>"},{"location":"ranges/#in-a-nutshell","title":"In a nutshell","text":"<ol> <li>Ranges in the form <code>start:end</code> include both the start and end position,    unless 0-based coordinates are configured.</li> <li>Negative coordinates (e.g. <code>-5:-1</code>) indicate coordinate offsets from the end</li> <li>Unbounded ranges (<code>start:</code> or <code>:end</code>)    include everything from <code>start</code> to the sequence end,    respectively from the beginning to <code>end</code>.    \"undefined\" equals to missing coordinates.</li> <li>If interpreting ranges as exclusive, the    actual start or end positions are not included in the range.</li> </ol>"},{"location":"ranges/#overview","title":"Overview","text":"<p>Ranges look like this: <code>start:end</code>. The the start and end positions are always part of the range, unless explicitly switching to 0-based coordinates.</p> <p>It is also possible to use negative numbers: <code>-1</code> references the last character in the sequence, <code>-2</code> the second last, and so on.</p> <pre>\n                   | &lt;\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014&gt; | \nsequence:       A   T   G   C   A   T   G   C\nbase number:    1   2   3   4   5   6   7   8\nfrom end:      -8  -7  -6  -5  -4  -3  -2  -1\n</pre> <p>The following commands all trim sequences to the blue range, resulting in the same output:</p> <pre><code>st trim '2:6' input.fasta\nst trim '-7:-3' input.fasta\nst trim '2:-3' input.fasta\n</code></pre>"},{"location":"ranges/#empty-ranges","title":"Empty ranges","text":"<p>Ranges of zero length are only possible if the start is greater than the end (e.g. <code>5:4</code>). seqtool interprets all ranges where start &gt; end as empty.</p> <p>An exception are 0-based ranges. In this specific mode, <code>5:5</code> would result in an empty range.</p>"},{"location":"ranges/#unbounded-ranges-start-or-end","title":"Unbounded ranges: <code>start:</code> or <code>:end</code>","text":"<p>The start or end positions can be missing, which results in the whole sequence up or from a certain position being included in the range.</p>"},{"location":"ranges/#no-end","title":"No end","text":"<p>The following retains all positions from <code>5</code> to the end:</p> <pre><code>st trim '5:' input.fasta\nst trim '-4:' input.fasta\n</code></pre> <pre>\n                               | &lt;\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014&gt;\nsequence:       A   T   G   C   A   T   G   C \nbase number:    1   2   3   4   5   6   7   8 \nfrom end:      -8  -7  -6  -5  -4  -3  -2  -1 \n</pre> <p>The sequence ends at position 8, so <code>5:</code> is equivalent to <code>5:8</code> or <code>5:-1</code>.</p> <p>However, if sequence lengths differ, only <code>5:</code> or <code>5:-1</code> will include everything after position 5, while <code>5:8</code> would still only return these fixed positions:</p> <pre>\nATGCATGC\nATGCATGCMORE\n</pre> <p>\u26a0\ufe0f <code>5:</code> is equivalent to <code>5:-1</code> here, but results can differ with exclusive ranges. Usually, you might want to use the unbounded <code>start:</code> range, which will always include the whole sequence end.</p>"},{"location":"ranges/#no-start","title":"No start","text":"<p>It is also possible to omit the start position to return all positions up to a given position:</p> <pre><code>st trim ':3' input.fasta\n</code></pre> <pre>\nATGCATGC\nATGCATGCMORE\n</pre> <p>\u26a0\ufe0f again, <code>0:3</code> is equivalent to <code>:3</code>, but only if not using exclusive ranges.</p>"},{"location":"ranges/#no-bounds-at-all","title":"No bounds at all","text":"<p>The following will retain the whole sequence, resulting in no trimming at all:</p> <pre><code>st trim \":\" input.fasta\n</code></pre> <pre>\nATGCATGC\nATGCATGCMORE\n</pre>"},{"location":"ranges/#undefined","title":"<code>undefined</code>","text":"<p>Undefined is a special keyword that equals to missing data and thus, <code>undefined:undefined</code> equals to an unbounded range <code>:</code>.</p> <p><code>undefined</code> may be returned by functions such as <code>opt_attr()</code> and <code>opt_meta()</code>.</p>"},{"location":"ranges/#exclusive-ranges-e-exclusive","title":"Exclusive ranges (<code>-e/--exclusive</code>)","text":"<p>The <code>trim</code> and <code>mask</code> commands also accept an <code>-e/--exclusive</code> argument that excludes start and end coordinates from the range.</p> <p>The following commands trim to positions 3-5 (blue) without the range bounds <code>2</code> and <code>6</code> themselves (red).</p> <pre><code>st trim -e '2:6' input.fasta\nst trim -e '-7:-3' input.fasta\n</code></pre> <pre>\n                       | &lt;\u2014\u2014\u2014\u2014\u2014\u2014&gt; |\nsequence:       A   T   G   C   A   T   G   C\nbase number:    1   2   3   4   5   6   7   8\nfrom end:      -8  -7  -6  -5  -4  -3  -2  -1\n</pre> <p>One important corner case are unbounded ranges. In case of missing bounds, the ranges are not trimmed or masked on that side, the range still extends to the start or end as if it would without <code>-e/--exclusive</code>:</p> <pre><code>st trim -e '5:' input.fasta\nst trim -e '-4:' input.fasta\n</code></pre> <pre>\n                                   | &lt;\u2014\u2014\u2014\u2014\u2014\u2014&gt;\nsequence:       A   T   G   C   A   T   G   C \nbase number:    1   2   3   4   5   6   7   8 \nfrom end:      -8  -7  -6  -5  -4  -3  -2  -1 \n</pre>"},{"location":"ranges/#0-based-coordinates-0","title":"0-based coordinates (<code>-0</code>)","text":"<p>If you prefer 0-based ranges common to many programming languages, specify the <code>-0</code> argument. These are less intuitive, but have the advantage that empty slices can be more easily obtained (e.g. <code>st trim -0 1:1</code>).</p> <p>The range indices start with <code>0</code> instead of <code>1</code>, and the range end (green) is not included in the slice. Negative indices are also possible and work exactly as in Python.</p> <pre>\n                   | &lt;\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014&gt; | \nsequence:       A   T   G   C   A   T   G   C\nbase number:    1   2   3   4   5   6   7   8\n0-based start:  0   1   2   3   4   5   6   7\nfrom end:      -8  -7  -6  -5  -4  -3  -2  -1\n</pre> <pre><code>st trim -0 '1:6' input.fasta\nst trim -0 '-7:-2' input.fasta\n</code></pre>"},{"location":"replace/","title":"replace","text":"<p>Fast and simple pattern replacement in sequences or headers</p> <p><pre><code>Usage: st replace [OPTIONS] &lt;PATTERN&gt; &lt;REPLACEMENT&gt; [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Replace' command options:\n  -i, --id           Replace in IDs instead of sequences\n  -d, --desc         Replace in descriptions\n  -r, --regex        Interpret pattern as a regular expression. Unicode\n                     characters are supported when searching in\n                     IDs/descriptions, but not for sequence searches\n  -t, --threads &lt;N&gt;  Number of threads [default: 1]\n  &lt;PATTERN&gt;          Search pattern\n  &lt;REPLACEMENT&gt;      Replacement string, cannot contain variables\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"replace/#examples","title":"Examples","text":""},{"location":"replace/#rna-to-dna","title":"RNA to DNA","text":"<p>Simple RNA to DNA conversion by replacing all occurrences of <code>U</code> with <code>T</code>:</p> <pre><code>st replace U T rna.fasta &gt; dna.fasta\n</code></pre>"},{"location":"replace/#regular-expressions","title":"Regular expressions","text":"<p>The following command extracts Genbank accessions from sequence headers that follow the old-style Genbank format, e.g. <code>gi|1031916024|gb|KU317675.1|</code>:</p> <pre><code>st replace -ir \"gi\\|\\d+\\|[a-z]+\\|(?&lt;acc&gt;.+?)\\|.*\" seqs.fasta '$acc' &gt; seqs_accession.fasta\n</code></pre> <p>The accession <code>KU317675.1</code> is matched by the named regex group 'acc' and referenced by <code>'$acc'</code>. Regular expression (regex) groups can be accessed with the '$' prefix in replacements.</p> <p>You can use online tools such as https://regex101.com to build and debug your regular expression</p> <p>\u26a0 In Bash, make sure to use single quotes around <code>'$acc'</code> (not double quotes) to avoid that <code>$acc</code> is interpreted as a shell variable.</p>"},{"location":"replace/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"revcomp/","title":"revcomp","text":"<p>Reverse complements DNA or RNA sequences</p> <p>The sequence type is automatically detected based on the first record, unless the <code>--seqtype</code> option is used.</p> <p>Note: Unknown letters are not reversed, but left unchanged.</p> <p>If quality scores are present, their order is just reversed</p> <p><pre><code>Usage: st revcomp [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Revcomp' command options:\n  -t, --threads &lt;THREADS&gt;  Number of threads to use [default: 1]\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"revcomp/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"sample/","title":"sample","text":"<p>Get a random subset of sequences; either a fixed number or an approximate fraction of the input</p> <p>The records are returned in input order.</p> <p><pre><code>Usage: st sample [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Sample' command options:\n  -n, --num-seqs &lt;N&gt;    Randomly select a fixed number of sequences. In case\n                        speed is important, consider -p/--prob. For lower memory\n                        usage (but less speed), supply -2/--to-pass\n  -p, --prob &lt;PROB&gt;     Instead of a fixed number, include each sequence with\n                        the given probability. There is no guarantee about an\n                        exact number of returned sequences, but the fraction of\n                        returned sequences will be near the specified\n                        probability\n  -s, --seed &lt;SEED&gt;     Use a seed to make the sampling reproducible. Useful\n                        e.g. for randomly selecting from paired end reads.\n                        Either a number (can be very large) or an ASCII string,\n                        from which the first 32 characters are used\n  -2, --two-pass        Use two-pass sampling with -n/--num-seqs: (1) read all\n                        files to obtain the total number of sequences, (2) read\n                        again, and return the selected sequences. This uses less\n                        memory, but does not work with STDIN and may be\n                        especially slow with compressed files. Automatically\n                        activated if the -M/--max-mem limit is reached\n  -M, --max-mem &lt;SIZE&gt;  Maximum amount of memory to use for sequences. Either a\n                        plain number (bytes) a number with unit (K, M, G, T)\n                        based on powers of 2. This limit may be hit if a large\n                        number of sequences is chosen (-n/--num-seqs). If\n                        reading from a file (not STDIN), the program will\n                        automatically switch to two-pass sampling mode.\n                        Alternatively, conider using -p/--prob if the number of\n                        returned sequences does not have to be exact [default:\n                        5G]\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"sample/#example","title":"Example","text":"<pre><code>st sample -n 100 input.fasta &gt; subset.fasta\n</code></pre>"},{"location":"sample/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"set/","title":"set","text":"<p>Replace the header, header attributes or sequence with new content</p> <p><pre><code>Usage: st set [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Set' command options:\n  -i, --id &lt;ID&gt;      New ID (variables allowed)\n  -d, --desc &lt;DESC&gt;  New description (variables allowed)\n  -s, --seq &lt;SEQ&gt;    New sequence (variables allowed)\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"slice/","title":"slice","text":"<p>Return a range of sequence records from the input</p> <p>The range is specified as <code>start:end</code>, whereby start and end are the sequence numbers (starting from 1). Open ranges are possible, in the form <code>start:</code> or <code>:end</code>.</p> <p>The following is equivalent with <code>st head input.fasta</code>: <code>st slice ':10' input.fasta</code></p> <p>The following is equivalent with <code>st tail input.fasta</code>:  <code>st slice '-10:' input.fasta</code></p> <p>The 'slice' command does not extract subsequences; see the 'trim' command for that.</p> <p><pre><code>Usage: st slice [OPTIONS] &lt;FROM:TO&gt; [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Slice' command options:\n  &lt;FROM:TO&gt;  Range in form 'start:end' or ':end' or 'start:'\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"sort/","title":"sort","text":"<p>Sort records by sequence or any other criterion</p> <p>The sort key can be 'seq', 'id', or any variable/function, expression, or text containing them (see  help and <code>st sort -V/--help-vars</code>). <p>Records with identical keys are kept in input order.</p> <p>The actual value of the key is available through the 'key' variable. It can be written to a header attribute or TSV field.</p> <p><pre><code>Usage: st sort [OPTIONS] &lt;KEY&gt; [INPUT]...\n\nOptions:\n  -h, --help  Print help (see more with '--help')\n\n'Sort' command options:\n  -r, --reverse              Sort in reverse order\n  -M, --max-mem &lt;SIZE&gt;       Maximum amount of memory (approximate) to use for\n                             sorting. Either a plain number (bytes) a number\n                             with unit (K, M, G, T) based on powers of 2\n                             [default: 5G]\n      --temp-dir &lt;PATH&gt;      Path to temporary directory (only if memory limit\n                             is exceeded)\n      --temp-file-limit &lt;N&gt;  Maximum number of temporary files allowed [default:\n                             1000]\n  &lt;KEY&gt;                      The key used to sort the records. It can be a\n                             single variable/function such as 'seq', 'id', a\n                             composed string, e.g. '{id}_{desc}', or a\n                             comma-delimited list of multiple\n                             variables/functions to sort by, e.g. 'seq,attr(a)'.\n                             In this case, the records are first sorted by\n                             sequence, but in case of identical sequences,\n                             records are sorted by the header attribute 'a'\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"sort/#more","title":"More","text":"<p>This page lists more examples with execution times and comparisons with other tools.</p>"},{"location":"sort/#variables-provided-by-the-sort-command","title":"Variables provided by the 'sort' command","text":"key The value of the key used for sorting"},{"location":"sort/#example","title":"Example","text":"<p>Sort by part of the sequence ID, which is obtained using a JavaScript expression. We additionally keep this substring by writing the sort key to a header attribute:: <pre><code>st sort -n '{ id.slice(2, 5) }' -a id_num='{num(key)}' input.fasta\n</code></pre> <pre><code>&gt;id001 id_num=1\nSEQ\n&gt;id002 id_num=2\nSEQ\n(...)\n</code></pre></p>"},{"location":"split/","title":"split","text":"<p>Distribute sequences into multiple files based on a variable/function or advanced expression</p> <p>In contrast to other commands, the output argument (<code>-o/--output</code>) of the 'split' command can contain variables and advanced expressions to determine the file path for each sequence. However, the output format will not be automatically determined from file extensions containing variables.</p> <p><pre><code>Usage: st split [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Split' command options:\n  -n, --num-seqs &lt;N&gt;     Split into chunks of &lt;N&gt; sequences and writes each\n                         chunk to a separate file with a numbered suffix. The\n                         output path is: '{filestem}_{chunk}.{default_ext}',\n                         e.g. 'input_name_1.fasta'. Change with `-o/--output`\n  -p, --parents          Automatically create all parent directories of the\n                         output path\n  -c, --counts &lt;COUNTS&gt;  Write a tab-separated list of file path + record count\n                         to the given file (or STDOUT if `-` is specified)\n</code></pre> See this page for the options common to all commands.</p> <p>Immagine this FASTA file (<code>input.fa</code>):</p> <pre><code>&gt;seq1 group=1\nSEQUENCE\n&gt;seq2 group=2\nSEQUENCE\n&gt;seq3 group=1\nSEQUENCE\n</code></pre> <pre><code>st split -o \"group_{attr(group)}.fa\" input.fasta\n</code></pre> <p>This will create the files <code>group_1.fa</code> and <code>group_2.fa</code>. In more complicated scenarios, variables may be combined for creating nested subfolders of any complexity.</p> <p>An example of de-multiplexing sequences by forward primer is found in the documetation of the find command.</p>"},{"location":"split/#variables-available-in-the-split-command","title":"Variables available in the split command","text":"chunk If <code>-n/--num-seqs</code> was specified, the 'chunk' variable contains the number of the current sequence batch, starting with 1. Note that the 'chunk' variable is only available with <code>-n/--num-seqs</code>, otherwise there will be a message: \"Unknown variable/function: chunk\"return type: number"},{"location":"split/#example","title":"Example","text":"<p>Split input into chunks of 1000 sequences, which will be named outdir/file_1.fq, outdir/file_2.fq, etc.: <pre><code>st split -n 1000 -po 'outdir/out_{chunk}.fq' input.fastq\n</code></pre> <pre><code>Output files (`ls outdir/out_*.fq`):\noutdir/out_1.fq\noutdir/out_2.fq\n(...)\n</code></pre></p>"},{"location":"stat/","title":"stat","text":"<p>Return per-sequence statistics as tab delimited list</p> <p>Sequence statistics variables (seqlen, exp_err, charcount(...), etc.) are supplied as comma-delimited list, e.g. <code>id,seqlen,exp_err</code>. The stat command is equivalent to <code>st pass --to-tsv 'id,var1,var2,...' input</code></p> <p>See <code>st stat -V/--help-vars</code> for a list of all possible variables.</p> <p><pre><code>Usage: st stat [OPTIONS] &lt;VAR&gt; [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Stat' command options:\n  &lt;VAR&gt;  Comma delimited list of statistics variables\n</code></pre> See this page for the options common to all commands.</p> <p><code>st stat &lt;variables&gt;</code> is a shorter equivalent of <code>st pass --to-tsv id,&lt;variables&gt;</code>.</p> <p>Example:</p> <pre><code>st stat seqlen,gc_percent seqs.fasta\n</code></pre> <p>Example output:</p> <pre><code>seq1    291 50.51546391752577\nseq2    297 57.57575757575758\n...\n</code></pre>"},{"location":"tail/","title":"tail","text":"<p>Return the last N sequences</p> <p>This only works for files (not STDIN), since records are counted in a first step, and only returned after reading a second time.</p> <p><pre><code>Usage: st tail [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Tail' command options:\n  -n, --num-seqs &lt;N&gt;  Number of sequences to return [default: 10]\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"trim/","title":"trim","text":"<p>Trim sequences on the left and/or right (single range) or extract and concatenate several ranges</p> <p><pre><code>Usage: st trim [OPTIONS] &lt;RANGES&gt; [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\n'Trim' command options:\n  -e, --exclusive   Exclusive trim range: excludes start and end positions from\n                    the output sequence. In the case of unbounded ranges\n                    (`start:` or `:end`), the range still extends to the\n                    complete end or the start of the sequence\n  -0, --zero-based  Interpret range as 0-based, with the end not included\n  &lt;RANGES&gt;          Range(s) in the form 'start:end' or 'start:' or ':end',\n                    Multiple ranges can be supplied as comma-delimited list:\n                    'start:end,start2:end2', etc. The start/end positions can be\n                    defined by variables/functions (start_var:end_var), or\n                    variables/functions may return the whole range (e.g. stored\n                    as header attribute 'attr(range)'), or even a list of ranges\n                    (e.g. 'attr(range_list)'). *Note* that with the FASTA\n                    format, multiple trim ranges must be in order (from left to\n                    right) and cannot overlap\n</code></pre> See this page for the options common to all commands.</p> <p>The trim ranges always include the start and end coordinates unless <code>-0</code> is specified. Coordinates can be negative to indicate an offset from the end. See explanation of ranges for more details.</p>"},{"location":"trim/#example-primer-trimming","title":"Example: primer trimming","text":"<p>Assuming the length of a primer is 20bp, we can remove it like this:</p> <pre><code>st trim \":20\" input.fasta &gt; output.fasta\n</code></pre> <p>However, primers may sometimes be incomplete or shifted, which is why tools such as Cutadapt are usually used to trim primers. Seqtool can do primer matching using the find command, followed by primer trimming with trim. The following example trims forward and reverse primers, storing the positions as attributes in sequence headers:</p> <pre><code>st find FWDPRIMER -f -R 0.1 -a fwd_end={match_end} input.fasta |\n  st find REVPRIMER -f -R 0.1 -a rev_start={match_start} |\n  st trim --exclusive '{attr(fwd_end)}:{attr(rev_start)}' &gt; primer_trimmed.fasta\n</code></pre> <p>The intermediate output before the trim command may look like this:</p> <pre>\n&gt;id f_end=15 r_start=24\nBEFOREFWDPRIMERSEQUENCEREVPRIMERAFTER\n</pre> <p><code>primer_trimmed.fasta</code>:</p> <pre>\n&gt;id f_end=15 r_start=-15\nSEQUENCE\n</pre> <p>Note: <code>-e/--exclusive</code> excludes the last base of the forward primer and the first base of the reverse primer.</p>"},{"location":"trim/#using-coordinates-from-bed-files","title":"Using coordinates from BED files","text":"<p>The following is equivalent to bedtools getfasta (note that the BED format is 0-based, thus the <code>-0</code> option):</p> <pre><code>st trim -l coordinates.bed -0 '{meta(2)}:{meta(3)}' input.fasta &gt; output.fasta\n</code></pre> <p>Instead of <code>-0</code> we could also use an expression to calculate <code>start + 1</code>, matching the standard range coordinate system used by seqtool.</p> <pre><code>st trim -l coordinates.bed '{meta(2)+1}:{meta(3)}' input.fasta &gt; output.fasta\n</code></pre>"},{"location":"trim/#multiple-ranges","title":"Multiple ranges","text":"<p>The trim command can also concatenate multiple parts of the sequence:</p> <pre><code>st trim '2:5,10:1' input.fasta &gt; output.fasta\n</code></pre>"},{"location":"trim/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"unique/","title":"unique","text":"<p>De-replicate by sequence and/or other properties, returning only unique records</p> <p>The unique key can be 'seq' or any variable/function, expression, or text containing them (see  help and <code>st unique -V/--help-vars</code>). <p>The order of the records is the same as in the input unless the memory limit is exceeded, in which case temporary files are used and all remaining records are sorted by the unique key. Use <code>-s/--sorted</code> to always sort the output by key.</p> <p><pre><code>Usage: st unique [OPTIONS] &lt;KEY&gt; [INPUT]...\n\nOptions:\n  -h, --help  Print help (see more with '--help')\n\n'Unique' command options:\n  -s, --sort                 Sort the output by key. Without this option, the\n                             records are in input order if the memory limit is\n                             *not* exceeded, but are sorted by key otherwise\n      --map-out &lt;MAP_OUT&gt;    Write a map of all duplicate sequence IDs to the\n                             given file (or '-' for stdout). The (optional)\n                             compression format is auto-recognized from the\n                             extension. By default, a two-column mapping of\n                             sequence ID -&gt; unique reference record ID is\n                             written (`long` format). More formats can be\n                             selected with `--map_format`\n      --map-fmt &lt;MAP_FMT&gt;    Column format for the duplicate map `--map-out`\n                             (use `--help` for details) [default: long]\n                             [possible values: long, long-star, wide,\n                             wide-comma, wide-key]\n  -M, --max-mem &lt;SIZE&gt;       Maximum amount of memory (approximate) to use for\n                             de-duplicating. Either a plain number (bytes) a\n                             number with unit (K, M, G, T) based on powers of 2\n                             [default: 5G]\n      --temp-dir &lt;PATH&gt;      Path to temporary directory (only if memory limit\n                             is exceeded)\n      --temp-file-limit &lt;N&gt;  Maximum number of temporary files allowed [default:\n                             1000]\n  &lt;KEY&gt;                      The key used to determine, which records are\n                             unique. The key can be a single variable/function\n                             such as 'seq', a composed string such as\n                             '{attr(a)}_{attr(b)}', or a comma-delimited list of\n                             multiple variables/functions, whose values are all\n                             taken into account, e.g. 'seq,num(attr(a))'. In\n                             case of identical sequences, records are still\n                             de-replicated by the header attribute 'a'. The\n                             'num()' function turns text values into numbers,\n                             which can speed up the de-replication. For each\n                             key, the *first* encountered record is returned,\n                             and all remaining ones with the same key are\n                             discarded\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"unique/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"unique/#variablesfunctions-provided-by-the-unique-command","title":"Variables/functions provided by the 'unique' command","text":"<p>see also <code>st unique -V</code> or <code>st unique --help-vars</code></p> key The value of the unique key n_duplicatesn_duplicates(include_self) The <code>n_duplicates</code> variable retuns the total number of duplicate records sharing the same unique key. It can also be used as a function <code>n_duplicates(false)</code> to exclude the returned unique record from the count. <code>n_duplicates</code> is short for <code>n_duplicates(true)</code>.return type: number duplicates_listduplicates_list(include_self) Returns a comma-delimited list of record IDs that share the same unique key. Make sure that the record IDs don't have commas in them. The ID of the returned unique record is included by default (<code>duplicate_list</code> is short for <code>duplicate_list(true)</code>) but can be excluded with <code>duplicate_list(false)</code>.return type: text"},{"location":"unique/#examples","title":"Examples","text":"<p>De-replicate sequences using the sequence hash (faster than using the sequence <code>seq</code> itself), and also storing the number of duplicates (including the unique sequence itself) in the sequence header: <pre><code>st unique seqhash -a abund={n_duplicates} input.fasta &gt; uniques.fasta\n</code></pre> <pre><code>&gt;id1 abund=3\nTCTTTAATAACCTGATTAG\n&gt;id3 abund=1\nGGAGGATCCGAGCG\n(...)\n</code></pre> Store the complete list of duplicate IDs in the sequence header: <pre><code>st unique seqhash -a duplicates={duplicate_list} input.fasta &gt; uniques.fasta\n</code></pre> <pre><code>&gt;id1 duplicates=id1,id2,id4\nTCTTTAATAACCTGATTAG\n&gt;id3 duplicates=id3\nGGAGGATCCGAGCG\n(...)\n</code></pre></p>"},{"location":"upper/","title":"upper","text":"<p>Convert sequences to uppercase</p> <p><pre><code>Usage: st upper [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n</code></pre> See this page for the options common to all commands.</p>"},{"location":"upper/#more","title":"More","text":"<p>This page lists examples with execution times compared to other tools.</p>"},{"location":"var_reference/","title":"Variables/functions: full reference","text":"<p>This list can also be viewed in the terminal by running <code>st command --help-vars</code></p>"},{"location":"var_reference/#general-properties-of-sequence-records-and-input-files","title":"General properties of sequence records and input files","text":"id Record ID (in FASTA/FASTQ: everything before first space)return type: text desc Record description (everything after first space)return type: text seq Record sequencereturn type: text upper_seq Record sequence in uppercase lettersreturn type: text lower_seq Record sequence in lowercase lettersreturn type: text seqhashseqhash(ignorecase) Calculates a hash value from the sequence using the XXH3 algorithm. A hash is a integer number representing the sequence. In very rare cases, different sequences may lead to the same hash value. Using 'seqhash' instead of 'seq' speeds up de-replication ('unique' command) and requires less memory, at a very small risk of wrongly recognizing two different sequences as duplicates. The returned numbers can be negative.return type: number seqhash_revseqhash_rev(ignorecase) The hash value of the reverse-complemented sequencereturn type: number seqhash_bothseqhash_both(ignorecase) The sum of the hashes from the forward and reverse sequences. The result is always the same irrespective of the sequence orientation, which is useful when de-replicating sequences with potentially different orientations. [side note: to be precise it is a wrapping addition to prevent integer overflow]return type: number seq_numseq_num(reset) Sequence number (n-th sequence in the input), starting from 1. The numbering continues across all provided sequence files unless <code>reset</code> is <code>true</code>, in which case the numbering re-starts from 1 for each new sequence file.Note that the output order can vary with multithreaded processing.return type: number seq_idxseq_idx(reset) Sequence index, starting from 0.The index is incremented across all provided sequence files unless <code>reset</code> is <code>true</code>, in which case the index is reset to 0 at the start of each new sequence file.Note that the output order can vary with multithreaded processing.return type: number path Path to the current input file (or '-' if reading from STDIN)return type: text filename Name of the current input file with extension (or '-')return type: text filestem Name of the current input file without extension (or '-')return type: text extension Extension of the current input file (or '')return type: text dirname Name of the base directory of the current file (or '')return type: text default_ext Default file extension for the configured output format (e.g. 'fasta' or 'fastq')return type: text"},{"location":"var_reference/#examples","title":"Examples","text":"<p>Add the sequence number to the ID: <pre><code>st set -i {id}_{seq_num}\n</code></pre> <pre><code>&gt;A_1\nSEQUENCE\n&gt;B_2\nSEQUENCE\n&gt;C_3\nSEQUENCE\n(...)\n</code></pre> Count the number of records per file in the input: <pre><code>st count -k path *.fasta\n</code></pre> <pre><code>file1.fasta 1224818\nfile2.fasta 573\nfile3.fasta 99186\n(...)\n</code></pre> Remove records with duplicate sequences from the input: <pre><code>st unique seq input.fasta\n</code></pre> Remove duplicate records irrespective of the sequence orientation and whether letters are uppercase or lowercase: <pre><code>st unique 'seqhash_both(true)' input.fasta\n</code></pre></p>"},{"location":"var_reference/#sequence-statistics","title":"Sequence statistics","text":"seqlen Sequence lengthreturn type: number ungapped_seqlen Ungapped sequence length (without gap characters <code>-</code>)return type: number gc GC content as fraction (0-1) of total bases. Lowercase (=masked) letters or characters other than ACGTU are not taken into account.return type: number gc_percent GC content as percentage of total bases. Lowercase (=masked) letters or characters other than ACGTU are not taken into account.return type: number charcount(characters) Count the occurrences of one or more single characters, which are supplied as a stringreturn type: number exp_err Total number of errors expected in the sequence, calculated from the quality scores as the sum of all error probabilities. For FASTQ, make sure to specify the correct format (--fmt) in case the scores are not in the Sanger/Illumina 1.8+ format.return type: number"},{"location":"var_reference/#examples_1","title":"Examples","text":"<p>List the GC content (in %) for every sequence: <pre><code>st stat gc_percent input.fa\n</code></pre> <pre><code>seq1    33.3333\nseq2    47.2652\nseq3    47.3684\n</code></pre> Remove DNA sequences with more than 1% ambiguous bases: <pre><code>st filter 'charcount(\"ACGT\") / seqlen &gt;= 0.99' input.fa\n</code></pre></p>"},{"location":"var_reference/#header-attributes","title":"Header attributes","text":"<p>Attributes stored in FASTA/FASTQ headers. The expected pattern is ' key=value', but other patterns can be specified with <code>--attr-format</code>.</p> attr(name) Obtain an attribute of given name (must be present in all sequences)return type: text opt_attr(name) Obtain an attribute value, or 'undefined' if missing (=undefined in JavaScript expressions)return type: text attr_del(name) Obtain an attribute (must be present), simultaneously removing it from the header.return type: text opt_attr_del(name) Obtain an attribute (may be missing), simultaneously removing it from the header.return type: text has_attr(name) Returns <code>true</code> if the given attribute is present, otherwise returns <code>false</code>. Especially useful with the <code>filter</code> command; equivalent to the expression <code>opt_attr(name) != undefined</code>.return type: boolean"},{"location":"var_reference/#examples_2","title":"Examples","text":"<p>Count the number of sequences for each unique value of an 'abund' attribute in the FASTA headers (.e.g. <code>&gt;id abund=3</code>), which could be the number of duplicates obtained by the unique command (see <code>st unique -V/--help-vars</code>): <pre><code>st count -k 'attr(abund)' seqs.fa\n</code></pre> <pre><code>1   12019\n2   2983\n3   568\n(...)\n</code></pre> Summarize over a 'abund' attribute directly appended to the sequence ID like this <code>&gt;id;abund=3</code>: <pre><code>st count -k 'attr(abund)' --attr-fmt ';key=value' seqs.fa\n</code></pre> Summarize over an attribute 'a', which may be 'undefined' (=missing) in some headers: <pre><code>st count -k 'opt_attr(a)' seqs.fa\n</code></pre> <pre><code>value1  6042\nvalue2  1012\nundefined   9566\n</code></pre></p>"},{"location":"var_reference/#access-metadata-from-delimited-text-files","title":"Access metadata from delimited text files","text":"<p>The following functions allow accessing associated metadata from plain delimited text files (optionally compressed, extension auto-recognized). Metadata files must always contain a column with the sequence ID (default: 1st column; change with <code>--meta-idcol</code>). The column delimiter is guessed from the extension or can be specified with <code>--meta-delim</code>. <code>.csv</code> is interpreted as comma(,)-delimited, <code>.tsv</code>/<code>.txt</code> or other (unknown) extensions are assumed to be tab-delimited. The first line is implicitly assumed to contain column names if a non-numeric field name is requested, e.g. <code>meta(fieldname)</code>. Use <code>--meta-header</code> to explicitly enable header lines even if column names are all numeric. Multiple metadata files can be supplied (<code>-m file1 -m file2 -m file3 ...</code>) and are addressed via <code>file-num</code> (see function descriptions). For maximum performance, provide metadata records in the same order as sequence records. Note: Specify <code>--dup-ids</code> if the sequence input is expected to contain duplicate IDs (which is rather unusual). See the help page (<code>-h/--help</code>) for more information.</p> meta(column)meta(column, file_number) Obtain a value an associated delimited text file supplied with <code>-m</code> or <code>--meta</code>. Individual columns from entries with matching record IDs are selected by number (1, 2, 3, etc.) or by their name according to the column names in the first row. Missing entries are not allowed. Column names can be in 'single' or \"double\" quotes (but quoting is only required in Javascript expressions).If there are multiple metadata files supplied with -m/--meta (<code>-m file1 -m file2 -m file3, ...</code>), the specific file can be referenced by supplying <code>\\&lt;file-number\\&gt;</code> (1, 2, 3, ...) as first argument, followed by the column number or name. This is not necessary if only a single file is supplied.return type: text opt_meta(column)opt_meta(column, file_number) Like <code>meta(...)</code>, but metadata entries can be missing, i.e. not every sequence record ID needs a matching metadata entry. Missing values will result in 'undefined' if written to the output (= undefined in JavaScript expressions).return type: text has_metahas_meta(file_number) Returns <code>true</code> if the given record has a metadata entry with the same ID in the in the given file. In case of multiple files, the file number must be supplied as an argument.return type: boolean"},{"location":"var_reference/#examples_3","title":"Examples","text":"<p>Add taxonomic lineages to the FASTA headers (after a space). The taxonomy is stored in a GZIP-compressed TSV file (column no. 2) to the FASTA headers: <pre><code>st set -m taxonomy.tsv.gz -d '{meta(2)}' input.fa &gt; output.fa\n</code></pre> <pre><code>&gt;id1 k__Fungi,p__Ascomycota,c__Sordariomycetes,(...),s__Trichoderma_atroviride\nSEQUENCE\n&gt;id2 k__Fungi,p__Ascomycota,c__Eurotiomycetes,(...),s__Penicillium_aurantiocandidum\nSEQUENCE\n(...)\n</code></pre> Add metadata from an Excel-generated CSV file (semicolon delimiter) to sequence headers as attributes (<code>-a/--attr</code>): <pre><code>st pass -m metadata.csv --meta-sep ';' -a 'info={meta(\"column name\")}' input.fa &gt; output.fa\n</code></pre> <pre><code>&gt;id1 info=some_value\nSEQUENCE\n&gt;id2 info=other_value\nSEQUENCE\n(...)\n</code></pre> Extract subsequences given a set of coordinates stored in a BED file (equivalent to <code>bedtools getfasta</code>): <pre><code>st trim -m coordinates.bed -0 {meta(2)}..{meta(3)} input.fa &gt; output.fa\n</code></pre> Filter sequences by ID, retaining only those present in the given text file: <pre><code>st filter -m selected_ids.txt 'has_meta()' input.fa &gt; output.fa\n</code></pre></p>"},{"location":"var_reference/#expressions-javascript","title":"Expressions (JavaScript)","text":"<p>Expressions with variables, from simple mathematical operations to arbitrarily complex JavaScript code. Expressions are always enclosed in { curly brackets }. These brackets are optional for simple variables/functions in some cases, but mandatory for expressions. In addition, the 'filter' command takes an expression (without { brackets }).</p> <p>Instead of JavaScript code, it is possible to refer to a source file using 'file:path.js'.</p> <p>Returned value: For simple one-liner expressions, the value is directly used. More complex scripts with multiple statements (if/else, loops, etc.) explicitly require a <code>return</code> statement to return the value.</p>"},{"location":"var_reference/#examples_4","title":"Examples","text":"<p>Calculate the number of ambiguous bases in a set of DNA sequences and add the result as an attribute (ambig=...) to the header: <pre><code>st pass -a ambig='{seqlen - charcount(\"ACGT\")}' seqs.fasta\n</code></pre> <pre><code>&gt;id1 ambig=3\nTCNTTAWTAACCTGATTAN\n&gt;id2 ambig=0\nGGAGGATCCGAGCG\n(...)\n</code></pre> Discard sequences with &gt;1% ambiguous bases or sequences shorter than 100bp: <pre><code>st filter 'charcount(\"ACGT\") / seqlen &gt;= 0.99 &amp;&amp; seqlen &gt;= 100' seqs.fasta\n</code></pre> Distribute sequences into different files by a slightly complicated condition. Note the 'return' statments are are necessary here, since this is not a simple expression. With even longer code, consider using an extra script and supplying -o \"outdir/{file:code.js}.fasta\" instead: <pre><code>st split -po \"outdir/{ if (id.startsWith('some_prefix_')) { return 'file_1' } return 'file_2' }.fasta\" input.fasta\n</code></pre> <pre><code>There should be two files now (`ls file_*.fasta`):\nfile_1.fasta\nfile_2.fasta\n</code></pre></p>"},{"location":"var_reference/#data-conversion-and-transformation","title":"Data conversion and transformation","text":"num(expression) Converts any expression or value to a decimal number. Missing (undefined/null) values are left as-is.return type: number bin(expression)bin(expression, interval) Groups a continuous numeric number into discrete bins with a given interval. The intervals are represented as '(start, end]', whereby start \\&lt;= value \\&lt; end; the intervals are thus open on the left as indicated by '(', and closed on the right, as indicated by ']'. If not interval is given, a default width of 1 is assumed.return type: text"},{"location":"var_reference/#examples_5","title":"Examples","text":"<p>Summarize by a numeric header attribute in the form '&gt;id n=3': <pre><code>st count -k 'num(attr(\"n\"))' seqs.fa\n</code></pre> <pre><code>1   1882\n2   901\n3   94\n(...)\n</code></pre> Summarize the distribution of the GC content in a set of DNA sequences in 5% intervals: <pre><code>st count -k 'bin(gc_percent, 5)' seqs.fa\n</code></pre> <pre><code>(15, 20]    73\n(20, 25]    3443\n(25, 30]    14138\n(30, 35]    34829\n(35, 40]    20354\n(40, 45]    12142\n(45, 50]    14019\n(50, 55]    968\n(55, 60]    8\n</code></pre></p>"},{"location":"variables/","title":"Variables/functions","text":"<p>Seqtool offers many variables/functions providing information about the sequence records or the results of some commands.</p>"},{"location":"variables/#types-of-variablesfunctions","title":"Types of variables/functions","text":"<p>The following variable categories are provided:</p> <ul> <li>General properties of sequence records:   sequence header (<code>id</code>, <code>desc</code>),   the sequence (<code>seq</code>, <code>upper_seq</code>, ...),   input file names/paths (<code>filename</code>, <code>path</code>,   ...), etc.</li> <li>Sequence statistics    such as the GC content (<code>gc_percent</code>), etc.</li> <li>Access to key=value attributes   in sequence headers (<code>attr(name)</code>, ...).   More on attributes here.</li> <li>Integration of    metadata from delimited text files   (<code>meta(field)</code>, ...). More on metadata here.</li> <li>Some commands provide the results of some calculations in the form of variables/functions   (find,   unique,   sort,   split)</li> </ul>"},{"location":"variables/#complete-reference","title":"Complete reference","text":"<p>\ud83d\udc49 Full reference of variables/functions provided by all commands (see command documentation for those provided by individual commands).</p>"},{"location":"variables/#use-in-seqtool-commands","title":"Use in seqtool commands","text":"<p>Variables/functions are usually written in curly braces: <code>{variable}</code>, although this is optional in some cases (see below).</p>"},{"location":"variables/#simple-example","title":"Simple example","text":"<p>The following command recodes IDs to <code>seq_1</code>, <code>seq_2</code>, <code>seq_3</code> etc. using the num variable:</p> <pre><code>st set -i seq_{num} seqs.fasta &gt; renamed.fasta\n</code></pre>"},{"location":"variables/#grouping-categorization","title":"Grouping / categorization","text":"<p>The sort, unique and count commands use variables/functions for grouping/categorization.</p> <p>The keys can be single variable/function (without braces) or composed of text with multiple variables/functions, e.g.: <code>{id}_{desc}</code> (braces required).</p> <p>The following command sorts sequences by length:</p> <pre><code>st sort seqlen input.fasta &gt; length_sorted.fasta\n</code></pre>"},{"location":"variables/#settingediting-header-attributes","title":"Setting/editing header attributes","text":"<p>Variables/functions are needed for composing header attributes (<code>-a/--attr</code> argument):</p> <pre><code>st find PATTERN input.fasta -a rng='{match_range}' &gt; with_range.fasta\n</code></pre> <pre><code>&gt;id1 rng=3:10\nSEQUENCE\n&gt;id2 rng=5:12\nSEQUENCE\n(...)\n</code></pre>"},{"location":"variables/#ranges-trimmask","title":"Ranges (trim/mask)","text":"<p>The trim and mask commands accept ranges or even lists of ranges in the form of variables.</p> <p>In this command, we trim the sequence using start and end coordinates stored in separate attributes:</p> <pre><code>&gt;id1 start=3 end=10\nSEQUENCE\n(...)\n</code></pre> <pre><code>st trim -e 'attr(start):attr(end)' input.fasta &gt; trimmed.fasta\n</code></pre> <p>Or, we just use the range stored as a whole in the sequence header (above example).</p> <pre><code>st trim -e 'attr(rng)' input.fasta &gt; trimmed.fasta\n</code></pre> <p>The handling multiple ranges is documented in a sequence masking example.</p>"},{"location":"variables/#delimited-text-output","title":"Delimited text output","text":"<p>Variables/functions are also used to define the content of delimited text files.</p> <p>This example searches a sequence ID prefix (everything before a dot <code>.</code>) using a regular expression, and returns the matched text as TSV:</p> <pre><code>st find -ir '[^.]+' seqs.fasta --to-tsv 'id,match,seq' &gt; out.tsv\n</code></pre> <p><code>out.tsv</code></p> <pre><code>seq1.suffix123  seq1    SEQUENCE`\nseq2.suffix_abc seq2    SEQUENCE`\n...\n</code></pre> <p>As with sort/unique/count keys, <code>{braces}</code> are not needed, unless a field is composed mixed text and/or other variables (more details below)</p>"},{"location":"variables/#expressions","title":"Expressions","text":"<p>Expressions can be used everywhere where variables/functions are allowed. They must always be written in <code>{braces}</code> (exception: filter expressions).</p> <p>Example: calculating the fraction of ambiguous bases for each sequence:</p> <pre><code>st stat '{ 1 - charcount(\"ATGC\")/seqlen }'\n</code></pre> <pre><code>id1 1\nid2 0.99\nid3 0.95\nid4 1\n...\n</code></pre>"},{"location":"variables/#use-of-braces","title":"Use of braces","text":"<p>The braced <code>{variable}</code> notation is always necessary...</p> <ul> <li>when setting/composing attributes with <code>-a/--attr key=value</code></li> <li>if variables/functions are mixed with plain text and/or other other variables</li> <li>in set, output paths in split, text replacements in find (<code>--repl</code>)</li> <li>with JavaScript expressions</li> </ul> <p>The braces can optionally be omitted if only a single variable/function is used as...</p> <ul> <li>sort, unique and count key, e.g.: <code>st sort seq input.fasta</code></li> <li>range bound in trim, mask, e.g.: <code>st trim 'attr(start):' input.fasta</code></li> <li>delimited text field, e.g.: <code>st pass input.fasta --to-tsv id,desc,seq</code></li> </ul>"},{"location":"view/","title":"view","text":"<p>View biological sequences, colored by base / amino acid, or by sequence quality</p> <p>Sequences are displayed on a single line and can be navigated with up/down/left/right arrow keys and by scrolling. They are progressively read into memory while navigating down.</p> <p>Color palettes can be viewed with <code>st view -p/--list-pal</code> and also configured (as described in this help page).</p> <p><pre><code>Usage: st view [OPTIONS] [INPUT]...\n\nOptions:\n  -h, --help  Print help\n\nGeneral 'view' command options:\n  -i, --id-len &lt;CHARS&gt;  Length of IDs in characters. Longer IDs are truncated\n                        (default: 10 - 100 depending on ID length)\n  -d, --show-desc       Show descriptions along IDs if there is enough space\n  -b, --bold            Print the sequence in bold letters. Bold text is always\n                        used with `--fg` if quality scores are present\n      --fg              Color the sequence (foreground) instead of instead of\n                        the background (and additionally printed in bold). The\n                        background is simultaneously colored by quality scores\n                        if present, unless `-Q/--no-qual` is used\n  -Q, --no-qual         Ignore quality scores and color only by the sequence\n\nColors:\n  -p, --list-pal           Show a list of all builtin palettes and exit\n      --dna-pal &lt;PAL&gt;      Color mapping for DNA. Palette name (hex code,\n                           CSS/SVG color name) or list of\n                           'base1:rrggbb,base2:rrggbb,...' (builtin palettes:\n                           dna, dna-bright, dna-dark, pur-pyrimid, gc-at)\n                           [default: dna]\n      --aa-pal &lt;PAL&gt;       Color mapping for amino acids. Palette name (hex\n                           code, CSS/SVG color name) or list of\n                           'base1:rrggbb,base2:rrggbb,...' (available: rasmol,\n                           polarity) [default: rasmol]\n      --qscale &lt;PAL&gt;       Color scale to use for coloring according to base\n                           quality. Palette name (hex code, CSS/SVG color name)\n                           or list of 'base1:rrggbb,base2:rrggbb,...' Palette\n                           name or sequence of hex codes from low to high\n                           [default: red-blue]\n      --textcols &lt;COLORS&gt;  Text colors used with background coloring. Specify\n                           as: &lt;dark&gt;,&lt;bright&gt;. Which one is used will be chosen\n                           depending on the brightness of the background\n                           [default: 333333,eeeeee]\n  -t, --truecolor &lt;?&gt;      Use 16M colors, not only 256. This has to be\n                           supported by the terminal. Useful if autorecognition\n                           fails [possible values: true, false]\n</code></pre> See this page for the options common to all commands.</p> <p>This command allows for viewing sequences in the terminal. The output is colored if the terminal supports colors. On UNIX systems (Linux, Mac OS, ...), the sequences are directly forwarded to the <code>less</code> pager command, which allows for navigating up and down or in horizontal direction. On Windows, this is not done.</p> <p>The first sequence line in the input is always used to determine the sequence type (DNA/RNA or Protein).</p> <p>Example view of DNA sequences:</p> <pre><code>st view seqs.fasta\n</code></pre> <p></p> <pre><code>st view H1.fasta\n</code></pre> <p>View of Histone H1 sequences, colored according to the RasMol scheme.</p> <p></p> <p>If quality scores are present (from FASTQ or QUAL files), the background is colored accordingly (configure with <code>--qscale</code> and <code>--qmax</code>):</p> <pre><code>st view seqs.fastq\n</code></pre> <p></p>"},{"location":"view/#palettes","title":"Palettes","text":"<p>There are multiple color schemes/palettes available, which can be configured using <code>--dna-pal</code>, <code>--aa-pal</code> and <code>--qscale</code>.</p> <p>A visualization of the builtin palettes is obtained with <code>st view --list-pal</code> or <code>st view -p</code>:</p> <p></p>"}]}